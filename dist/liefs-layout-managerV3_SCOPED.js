/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var llm;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/liefs-layout-managerV3_FULL_MODULE.js":
/*!****************************************************!*\
  !*** ./dist/liefs-layout-managerV3_FULL_MODULE.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pf\": () => (/* binding */ pf),\n/* harmony export */   \"Arguments_\": () => (/* binding */ Arguments_),\n/* harmony export */   \"Base\": () => (/* binding */ Base),\n/* harmony export */   \"Component\": () => (/* binding */ Component),\n/* harmony export */   \"FunctionStack_BASE\": () => (/* binding */ FunctionStack_BASE),\n/* harmony export */   \"FunctionStack\": () => (/* binding */ FunctionStack),\n/* harmony export */   \"debounce_\": () => (/* binding */ debounce_),\n/* harmony export */   \"debounce\": () => (/* binding */ debounce),\n/* harmony export */   \"node_\": () => (/* binding */ node_),\n/* harmony export */   \"sample\": () => (/* binding */ sample),\n/* harmony export */   \"Point\": () => (/* binding */ Point),\n/* harmony export */   \"Within\": () => (/* binding */ Within),\n/* harmony export */   \"Coord\": () => (/* binding */ Coord),\n/* harmony export */   \"events\": () => (/* binding */ events),\n/* harmony export */   \"Element_\": () => (/* binding */ Element_),\n/* harmony export */   \"DisplayCell\": () => (/* binding */ DisplayCell),\n/* harmony export */   \"DisplayGroup\": () => (/* binding */ DisplayGroup),\n/* harmony export */   \"h\": () => (/* binding */ h),\n/* harmony export */   \"v\": () => (/* binding */ v),\n/* harmony export */   \"Handler\": () => (/* binding */ Handler),\n/* harmony export */   \"H\": () => (/* binding */ H),\n/* harmony export */   \"Css\": () => (/* binding */ Css),\n/* harmony export */   \"css\": () => (/* binding */ css),\n/* harmony export */   \"Render\": () => (/* binding */ Render),\n/* harmony export */   \"ScrollBar\": () => (/* binding */ ScrollBar),\n/* harmony export */   \"scrollbar\": () => (/* binding */ scrollbar),\n/* harmony export */   \"onDrag_\": () => (/* binding */ onDrag_),\n/* harmony export */   \"onDrag\": () => (/* binding */ onDrag),\n/* harmony export */   \"onHoldClick_\": () => (/* binding */ onHoldClick_),\n/* harmony export */   \"onHoldClick\": () => (/* binding */ onHoldClick),\n/* harmony export */   \"Selected\": () => (/* binding */ Selected),\n/* harmony export */   \"Pages\": () => (/* binding */ Pages),\n/* harmony export */   \"P\": () => (/* binding */ P),\n/* harmony export */   \"Tree_\": () => (/* binding */ Tree_),\n/* harmony export */   \"Context\": () => (/* binding */ Context),\n/* harmony export */   \"context\": () => (/* binding */ context),\n/* harmony export */   \"Modal\": () => (/* binding */ Modal),\n/* harmony export */   \"winModal\": () => (/* binding */ winModal),\n/* harmony export */   \"Stretch\": () => (/* binding */ Stretch),\n/* harmony export */   \"DragBar\": () => (/* binding */ DragBar),\n/* harmony export */   \"dragbar\": () => (/* binding */ dragbar)\n/* harmony export */ });\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n};\r\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n};\r\nclass pf {\r\n    static commonKeys(obj1, obj2) {\r\n        let returnStringArray = [];\r\n        for (let index in obj1)\r\n            if (index in obj2)\r\n                returnStringArray.push(index);\r\n        return returnStringArray;\r\n    }\r\n    static viewport() {\r\n        var width = window.innerWidth || document.documentElement.clientWidth ||\r\n            document.body.clientWidth;\r\n        var height = window.innerHeight || document.documentElement.clientHeight ||\r\n            document.body.clientHeight;\r\n        return [width, height];\r\n    }\r\n    static errorReporting(errString) {\r\n        console.log(\"Error Reporting\");\r\n        console.log(errString);\r\n    }\r\n    static insideOfFunctionString(functionString) {\r\n        return functionString.substring(functionString.indexOf(\"{\") + 1, functionString.lastIndexOf(\"}\"));\r\n    }\r\n    static array_move(arr, old_index, new_index) {\r\n        if (new_index >= arr.length) {\r\n            var k = new_index - arr.length + 1;\r\n            while (k--) {\r\n                arr.push(undefined);\r\n            }\r\n        }\r\n        arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);\r\n    }\r\n    ;\r\n    static undefinedIs(thing, value = 0) { return (thing == undefined) ? value : thing; }\r\n    static preUnderscore(someString) { return someString.substring(0, someString.indexOf(\"_\")); }\r\n    static uis0(num) { return (num == undefined) ? 0 : num; }\r\n    static parseURLParams(url = window.location.href) {\r\n        let queryStart = url.indexOf(\"?\") + 1, queryEnd = url.indexOf(\"#\") + 1 || url.length + 1, query = url.slice(queryStart, queryEnd - 1), pairs = query.replace(/\\+/g, \" \").split(\"&\"), parms = {}, i, n, v, nv;\r\n        if (query === url || query === \"\")\r\n            return;\r\n        for (i = 0; i < pairs.length; i++) {\r\n            nv = pairs[i].split(\"=\", 2);\r\n            n = decodeURIComponent(nv[0]);\r\n            v = decodeURIComponent(nv[1]);\r\n            if (!parms.hasOwnProperty(n))\r\n                parms[n] = [];\r\n            parms[n].push(nv.length === 2 ? v : null);\r\n        }\r\n        return parms;\r\n    }\r\n    static decimalPlaces(number, places) { return Math.round(Math.pow(10, places) * number) / Math.pow(10, places); }\r\n}\r\npf.isTypePx = function (it) { if (typeof (it) == \"string\" && it.substr(-2) == \"px\")\r\n    return true; return false; };\r\npf.pxAsNumber = function (dim) { return +(dim.slice(0, -2)); };\r\npf.isTypePercent = function (it) { if (typeof (it) == \"string\" && it.substr(-1) == \"%\")\r\n    return true; return false; };\r\npf.percentAsNumber = function (dim) { return +(dim.slice(0, -1)); };\r\npf.isDim = function (it) { if ((typeof (it) == \"string\") && (it.substr(-2) == \"px\" || it.substr(-1) == \"%\"))\r\n    return \"dim\"; };\r\npf.isArray = function (it) { if (typeof (it) == \"object\" && Array.isArray(it))\r\n    return \"Array\"; };\r\npf.isObjectAClass = function (it) { if (typeof (it) == \"object\" && it.constructor.name != \"Object\")\r\n    return it.constructor.name; };\r\npf.defaultIsChecks = [pf.isArray, pf.isObjectAClass, pf.isDim];\r\npf.classProperties = function (a) { return Object.getOwnPropertyNames(a); };\r\npf.pad_with_zeroes = function (Number, length = 3) {\r\n    let returnString = '' + Number;\r\n    while (returnString.length < length)\r\n        returnString = '0' + returnString;\r\n    return returnString;\r\n};\r\npf.mergeObjects = function (startObj, AddObj) {\r\n    let returnObject = {};\r\n    for (let i in startObj)\r\n        returnObject[i] = startObj[i];\r\n    for (let j in AddObj)\r\n        returnObject[j] = AddObj[j];\r\n    return returnObject;\r\n};\r\n/**\r\n * Arguments_ :\r\n * This object is responsible for sorting Arguments for a new class or function.\r\n *\r\n */\r\nclass Arguments_ {\r\n    /**\r\n     * Arguments by type\r\n     * @param Args Array of Arguments ie new Class(...Args)\r\n     * @param [customTypes] Array of Functions returning Type Name (if qualifies), or undefined.\r\n     * @returns An Object Key \"TypeName\", value Array of Arguments, of that Type, in the order discovered\r\n     */\r\n    static argumentsByType(Args, // 1st argument is a list of args.\r\n    customTypes = []) {\r\n        customTypes = customTypes.concat(Base.defaultIsChecks); // assumed these are included.\r\n        let returnObject = {};\r\n        let valueType;\r\n        let returnValue;\r\n        for (let value of Args) {\r\n            valueType = typeof (value); // evaluate type\r\n            for (let checkFunction of customTypes) { // check if it is a custom Type\r\n                returnValue = checkFunction(value);\r\n                if (returnValue)\r\n                    valueType = returnValue;\r\n            }\r\n            if (!(valueType in returnObject))\r\n                returnObject[valueType] = []; // If type doesn't exist, add empty array\r\n            returnObject[valueType].push(value); // Assign Type Value\r\n        }\r\n        return returnObject;\r\n    }\r\n    /**\r\n     * This function merges the defaults Object, with Argument Object(s)\r\n     * @param THIS - Class Object instance, like \"DisplayCell\"\r\n     * @param CLASS - Class (static) Object\r\n     * @returns Defaults Objects merged with Argument Objects\r\n     */\r\n    static ifObjectMergeWithDefaults(THIS, CLASS) {\r\n        if (\"object\" in THIS.retArgs) {\r\n            let returnObj = CLASS.defaults; // mergeObjects doens't overwrite this!\r\n            for (let key in THIS.retArgs[\"object\"])\r\n                returnObj = Arguments_.mergeObjects(returnObj, THIS.retArgs[\"object\"][key]);\r\n            return returnObj;\r\n        }\r\n        return CLASS.defaults;\r\n    }\r\n    /**\r\n     * retArgsMapped\r\n     * @param updatedDefaults (Return of Arguments_.ifObjectMergeWithDefaults())\r\n     * @param THIS - Class Object instance, like \"DisplayCell\"\r\n     * @param CLASS - Class (static) Object\r\n     * @returns args mapped\r\n     */\r\n    static retArgsMapped(updatedDefaults, THIS, CLASS) {\r\n        let returnObject = {};\r\n        let indexNo;\r\n        for (let i in updatedDefaults)\r\n            returnObject[i] = updatedDefaults[i];\r\n        for (let typeName in THIS.retArgs) {\r\n            if (typeName in CLASS.argMap) {\r\n                indexNo = 0;\r\n                while (indexNo < THIS.retArgs[typeName].length &&\r\n                    indexNo < CLASS.argMap[typeName].length) {\r\n                    returnObject[CLASS.argMap[typeName][indexNo]] = THIS.retArgs[typeName][indexNo];\r\n                    indexNo++;\r\n                }\r\n            }\r\n        }\r\n        return returnObject;\r\n    }\r\n    /**\r\n     * Similar to javascript typeof, but returns custom types like \"dim\" (ending in \"px\" or \"%\")\r\n     * @param Argument\r\n     * @returns Type Name (If Object, Class Name)\r\n     */\r\n    static typeof(Argument) { return (Object.keys(Arguments_.argumentsByType([Argument])))[0]; }\r\n    /**\r\n     * Modifys class properties\r\n     * @param argobj - Object to be mapped from\r\n     * @param targetobject - Object (Class Instance) to be mapped to\r\n     */\r\n    static modifyClassProperties(argobj, targetobject) {\r\n        for (let key of Object.keys(argobj))\r\n            targetobject[key] = argobj[key];\r\n    }\r\n}\r\n/**\r\n * Standard Merge objects function\r\n */\r\nArguments_.mergeObjects = function (startObj, AddObj) {\r\n    let returnObject = {};\r\n    for (let i in startObj)\r\n        returnObject[i] = startObj[i];\r\n    for (let j in AddObj)\r\n        returnObject[j] = AddObj[j];\r\n    return returnObject;\r\n};\r\n/**\r\n * Base Class for most Classes (Extends Base)\r\n */\r\nclass Base /* extends Function */ {\r\n    /**\r\n     * Creates an instance of base.  This is called by the extended class\r\n     * @param neverRead\r\n     */\r\n    constructor(...neverRead) { }\r\n    buildBase(...Arguments) { this.constructor[\"buildBase\"](this, ...Arguments); }\r\n    /**\r\n     * Sorts Agruments by type, then applies them as attributes to the Class Object Instance,\r\n     * according to default arguments map (argMap)  This is called by all Objects in the Constructor\r\n     * @param THIS\r\n     * @param Arguments\r\n     */\r\n    static buildBase(THIS, ...Arguments) {\r\n        let CLASS = this;\r\n        THIS.retArgs = Arguments_.argumentsByType(Arguments);\r\n        let updatedDefaults = Arguments_.ifObjectMergeWithDefaults(THIS, CLASS);\r\n        let retArgsMapped = Arguments_.retArgsMapped(updatedDefaults, THIS, CLASS);\r\n        Arguments_.modifyClassProperties(retArgsMapped, THIS);\r\n    }\r\n    /**\r\n     * If label is not defined, create One.\r\n     * @param instance\r\n     */\r\n    static makeLabel(instance) {\r\n        let CLASS = this;\r\n        if (instance[\"label\"] == undefined || instance[\"label\"].trim() == \"\") {\r\n            instance[\"label\"] = `${CLASS[\"name\"]}_${++CLASS[\"labelNo\"]}`;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Default custom check Function List (Array)\r\n */\r\nBase.defaultIsChecks = [pf.isArray, pf.isObjectAClass, pf.isDim];\r\nclass Component extends Base {\r\n    /**\r\n     * When Parent DisplayCell Discovers this Component, onConnect is called by the Parent DisplayCell\r\n     */\r\n    onConnect() { }\r\n    ;\r\n    /**\r\n     * Pre Stage of Rendering a Page.  It is useful if a child component wished to modify a parent\r\n     * component.  The parent is first altered here, then properly rendered at the Render Stage\r\n     * @param derender - True if this and children are to be DE-Rendered, not rendered.\r\n     * @param node - Render Node passed by Render Class\r\n     * @param zindex - Current zindex - Note: this is normally READ ONlY\r\n     * @returns array of children to be rendered (Normally empty, since Render phase is usually a better choice)\r\n     */\r\n    preRender(derender, node, zindex) { return undefined; }\r\n    ;\r\n    /**\r\n     * Rendering stage of aa Page.(After preRender phase).  In this function, usually the Co-ordinates of\r\n     * a child/childrend are calculated, and assigned, to be returned as an array\r\n     * @param derender  - True if this and children are to be DE-Rendered, not rendered.\r\n     * @param node - Render Node passed by Render Class\r\n     * @param zindex - Current zindex - Note: this is normally READ ONlY\r\n     * @returns array of children to be rendered\r\n     */\r\n    Render(derender, node, zindex) { return undefined; }\r\n    ;\r\n    /**\r\n     * Returns Child (in .children) by label\r\n     * @param label\r\n     * @returns child DisplayCell/Component\r\n     */\r\n    getChild(label) {\r\n        for (let index = 0; index < this.children.length; index++)\r\n            if (this.children[index].label == label)\r\n                return this.children[index];\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Deletes component\r\n     */\r\n    delete() { }\r\n}\r\n// The following is boierplate code, and left here for reference\r\n// class Test extends Base {\r\n//     static labelNo = 0;\r\n//     static instances:{[key: string]: Test;} = {};\r\n//     static activeInstances:{[key: string]: Test;} = {};\r\n//     static defaults:{[key: string]: any;} = {}\r\n//     static argMap:{[key: string]: Array<string>;} = {\r\n//         string : [\"label\", \"innerHTML\", \"css\"],\r\n//         number : [\"marginLeft\", \"marginTop\", \"marginRight\", \"marginBottom\"],\r\n//     }\r\n//     // retArgs:objectAny;   // <- this will appear\r\n//     constructor(...Arguments:any){\r\n//         super();this.buildBase(...Arguments);\r\n//         Test.makeLabel(this); Test.instances[this.label] = this;\r\n//     }\r\n// }\r\n/**\r\n * Function stack base\r\n */\r\nclass FunctionStack_BASE extends Function {\r\n    constructor() {\r\n        super('...args', 'return this.__self__.__call__(...args)');\r\n        let self = this.bind(this);\r\n        this[\"__self__\"] = self;\r\n        return self;\r\n    }\r\n}\r\n/**\r\n * Function stack\r\n */\r\nclass FunctionStack extends FunctionStack_BASE {\r\n    constructor() {\r\n        super();\r\n        this.functionArray = [];\r\n    }\r\n    /**\r\n     * Determines whether call\r\n     * @param Arguments\r\n     */\r\n    __call__(...Arguments) {\r\n        let elTarget = Arguments[0][\"target\"];\r\n        if (this.functionArray && this.functionArray.length)\r\n            for (let index = 0; index < this.functionArray.length; index++)\r\n                this.functionArray[index].bind(elTarget)(...Arguments);\r\n    }\r\n    /**\r\n     * Pushs function stack\r\n     * @param prevFunction\r\n     * @param [newFunction]\r\n     * @returns\r\n     */\r\n    static push(prevFunction, newFunction = undefined) {\r\n        let functionStackInstance;\r\n        if (prevFunction && prevFunction.constructor && prevFunction.constructor.name == \"FunctionStack\")\r\n            functionStackInstance = prevFunction;\r\n        else {\r\n            functionStackInstance = new FunctionStack();\r\n            if (prevFunction && typeof (prevFunction) == \"function\")\r\n                functionStackInstance.functionArray.push(prevFunction);\r\n        }\r\n        if (newFunction) {\r\n            if (newFunction.constructor && newFunction.constructor.name == \"FunctionStack\")\r\n                functionStackInstance.functionArray = functionStackInstance.functionArray.concat(newFunction.functionArray);\r\n            else\r\n                functionStackInstance.functionArray.push(newFunction);\r\n        }\r\n        return functionStackInstance;\r\n    }\r\n    /**\r\n     * Pops function stack\r\n     * @param functionStackInstance\r\n     * @param label\r\n     * @returns\r\n     */\r\n    static pop(functionStackInstance, label) {\r\n        for (let index = 0; index < functionStackInstance.functionArray.length; index++)\r\n            if (label == functionStackInstance.functionArray[index].name)\r\n                functionStackInstance.functionArray.splice(index--, 1);\r\n        return functionStackInstance;\r\n    }\r\n    /**\r\n     * Determines whether in is\r\n     * @param functionStackInstance\r\n     * @param label\r\n     * @returns\r\n     */\r\n    static isIn(functionStackInstance, label) {\r\n        for (let index = 0; index < functionStackInstance.functionArray.length; index++)\r\n            if (label == functionStackInstance.functionArray[index].name)\r\n                return true;\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Debounce\r\n */\r\nclass debounce_ extends FunctionStack_BASE {\r\n    /**\r\n     * Creates an instance of debounce .\r\n     * @param FUNCTION\r\n     * @param delay\r\n     */\r\n    constructor(FUNCTION, delay) {\r\n        super();\r\n        this.FUNCTION = FUNCTION;\r\n        this.delay = delay;\r\n        this.lasttime = new Date().getTime();\r\n    }\r\n    /**\r\n     * Determines whether call\r\n     * @param Arguments\r\n     */\r\n    __call__(...Arguments) {\r\n        let thistime = new Date().getTime();\r\n        if (thistime - this.lasttime > this.delay) {\r\n            this.FUNCTION(...Arguments);\r\n            this.lasttime = thistime;\r\n        }\r\n    }\r\n}\r\nfunction debounce(FUNCTION, delay) { return new debounce_(FUNCTION, delay); }\r\n/**\r\n * Node - A basic Tree Object.  Node by itself doesn't do much.\r\n * It purpose is determined by its parent, usually a Tree_ Object\r\n */\r\nclass node_ extends Base {\r\n    /**\r\n     * Creates an instance of node .\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.ParentNode = undefined;\r\n        this.children = [];\r\n        this.buildBase(...Arguments);\r\n        this.Arguments = Arguments;\r\n        if (!this.label)\r\n            node_.makeLabel(this);\r\n    }\r\n    /**\r\n     * New node - Used Interally\r\n     * @param THIS\r\n     * @param Arguments\r\n     * @returns\r\n     */\r\n    static newNode(THIS, ...Arguments) {\r\n        let newnode = new node_(...Arguments);\r\n        newnode.ParentNodeTree = THIS.ParentNodeTree;\r\n        return newnode;\r\n    }\r\n    /**\r\n     * Returns a Tree Structure, as An Array\r\n     * @param node\r\n     * @param [traverseFunction]\r\n     * @returns array\r\n     */\r\n    static asArray(node, traverseFunction = function (node) { return node; }) {\r\n        let returnArray = [];\r\n        node_.traverse(node, function (node) { returnArray.push(traverseFunction(node)); });\r\n        return returnArray;\r\n    }\r\n    /**\r\n     * Traverses node\r\n     * @param node - parent starting node\r\n     * @param traverseFunction - what to do on each iteration\r\n     * @param [traverseChildren] - Boolean Return - Traverse this Child?\r\n     * @param [traverseNode] - Boolean Return - Traverse this Node?\r\n     */\r\n    static traverse(node, traverseFunction, traverseChildren = function () { return true; }, traverseNode = function () { return true; }) {\r\n        if (traverseNode(node)) {\r\n            traverseFunction(node);\r\n            if (traverseChildren(node))\r\n                if (node.children)\r\n                    for (let index = 0; index < node.children.length; index++)\r\n                        node_.traverse(node.children[index], traverseFunction, traverseChildren, traverseNode);\r\n        }\r\n    }\r\n    /**\r\n     * Gets previous sibling\r\n     */\r\n    get PreviousSibling() {\r\n        if (!this.ParentNode)\r\n            return undefined;\r\n        let index = this.ParentNode.children.indexOf(this);\r\n        return (index > 0) ? this.ParentNode.children[index - 1] : undefined;\r\n    }\r\n    set PreviousSibling(newNode) {\r\n        if (this.ParentNode) {\r\n            let index = this.ParentNode.children.indexOf(this);\r\n            this.ParentNode.children.splice(index, 0, newNode);\r\n        }\r\n    }\r\n    /**\r\n     * Gets next sibling\r\n     */\r\n    get NextSibling() {\r\n        if (!this.ParentNode)\r\n            return undefined;\r\n        let index = this.ParentNode.children.indexOf(this);\r\n        return (index > -1 && index < this.ParentNode.children.length - 1) ? this.ParentNode.children[index + 1] : undefined;\r\n    }\r\n    set NextSibling(newNode) {\r\n        if (this.ParentNode) {\r\n            let index = this.ParentNode.children.indexOf(this);\r\n            this.ParentNode.children.splice(index + 1, 0, newNode);\r\n        }\r\n    }\r\n    /**\r\n     * Depth - returns number of steps up parent, to reach the root\r\n     * @param [deep]\r\n     * @returns\r\n     */\r\n    depth(deep = 0) {\r\n        let node = this;\r\n        while (node) {\r\n            deep += 1;\r\n            node = node.parent();\r\n        }\r\n        ;\r\n        return deep;\r\n    }\r\n    /**\r\n     * Length - returns number of node children (Recursive)\r\n     * @param [count]\r\n     * @returns\r\n     */\r\n    length(count = -1) {\r\n        node_.traverse(this, function (node) { count++; });\r\n        return count;\r\n    }\r\n    /**\r\n     * Create New Child Node.\r\n     * Either a) Fill node.Arguements Array or\r\n     * b) insert type node here.\r\n     * @param Arguments\r\n     * @returns child\r\n     */\r\n    newChild(...Arguments) {\r\n        let newNode;\r\n        if (typeof (Arguments[0]) == \"object\" && Arguments[0].constructor.name == \"node_\")\r\n            newNode = (Arguments[0]);\r\n        else\r\n            newNode = node_.newNode(this, ...Arguments);\r\n        newNode.ParentNodeTree = this.ParentNodeTree;\r\n        newNode.ParentNode = this;\r\n        this.children.push(newNode);\r\n        return newNode;\r\n    }\r\n    /**\r\n     * Create New Sibling Node\r\n     * Either a) Fill node.Arguements Array or\r\n     * b) insert type node here.\r\n     * @param Arguments\r\n     * @returns sibling\r\n     */\r\n    newSibling(...Arguments) {\r\n        let newNode;\r\n        if (typeof (Arguments[0]) == \"object\" && Arguments[0].constructor.name == \"node_\")\r\n            newNode = (Arguments[0]);\r\n        else\r\n            newNode = node_.newNode(this, ...Arguments);\r\n        newNode.ParentNodeTree = this.ParentNodeTree;\r\n        newNode.ParentNode = this.ParentNode;\r\n        this.NextSibling = newNode;\r\n        return newNode;\r\n    }\r\n    /**\r\n     * Pops node from node tree\r\n     * @returns\r\n     */\r\n    pop() {\r\n        this.ParentNode.children.splice(this.ParentNode.children.indexOf(this), 1);\r\n        this.ParentNode = undefined;\r\n        return this;\r\n    }\r\n    /**\r\n     * Done - returns ParentNodeTree\r\n     * @returns\r\n     */\r\n    done() { return this.ParentNodeTree; }\r\n    /**\r\n     * Return Root Node Of Tree\r\n     * @returns\r\n     */\r\n    root() {\r\n        let node = this;\r\n        while (node.parent()) {\r\n            node = node.parent();\r\n        }\r\n        return node;\r\n    }\r\n    /**\r\n     * Returns Parent of Current Node\r\n     * @returns\r\n     */\r\n    parent() { return this.ParentNode; }\r\n    /**\r\n     * Logs node to console.  set (true) to get full node objects as well\r\n     * @param [showNode]\r\n     */\r\n    log(showNode = false) {\r\n        if (this.children.length) {\r\n            console.groupCollapsed(this.label);\r\n            if (showNode)\r\n                console.log(this);\r\n            for (let index = 0; index < this.children.length; index++)\r\n                this.children[index].log(showNode);\r\n            console.groupEnd();\r\n        }\r\n        else {\r\n            if (showNode) {\r\n                console.groupCollapsed(this.label);\r\n                console.log(this);\r\n                console.groupEnd();\r\n            }\r\n            else\r\n                console.log(this.label);\r\n        }\r\n    }\r\n}\r\nnode_.labelNo = 0;\r\nnode_.instances = {};\r\nnode_.activeInstances = {};\r\nnode_.defaults = { collapsed: false };\r\nnode_.argMap = {\r\n    string: [\"label\"],\r\n};\r\n// Sample Node Provided in Source\r\nfunction sample() {\r\n    let node = new node_();\r\n    node.newChild(\"One\")\r\n        .newChild(\"One-A\")\r\n        .newChild(\"One-A-1\")\r\n        .newSibling(\"One-A-2\")\r\n        .parent()\r\n        .newSibling(\"One-B\")\r\n        .newChild(\"One-B-1\")\r\n        .newSibling(\"One-B-2\")\r\n        .newChild(\"One-B-2-1\")\r\n        .parent()\r\n        .parent()\r\n        .newSibling(\"One-C\")\r\n        .parent()\r\n        .newSibling(\"Two\")\r\n        .newChild(\"Two-A\")\r\n        .newChild(\"Two-A-1\")\r\n        .parent()\r\n        .newSibling(\"Two-B\")\r\n        .parent()\r\n        .newSibling(\"Three\");\r\n    return node;\r\n}\r\nvar _x_, _y_, _width_, _height_;\r\n/**\r\n * Point - Yea, a interface would do the same thing... so whats the point!\r\n */\r\nclass Point {\r\n}\r\n/**\r\n * Within - Coordinates of the Parent - to determine if this (child) is partially cut off\r\n * or goes partially (or completly) out of view\r\n */\r\nclass Within {\r\n    /**\r\n     * Creates an instance of within.\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) { }\r\n    get x() { return (this.lockedToScreenSize) ? 0 : this.x_; }\r\n    set x(x) { this.x_ = x; }\r\n    get y() { return (this.lockedToScreenSize) ? 0 : this.y_; }\r\n    set y(y) { this.y_ = y; }\r\n    get width() { return (this.lockedToScreenSize) ? Handler.ScreenSizeCoord.width : this.width_; }\r\n    set width(width) { this.width_ = width; }\r\n    get height() { return (this.lockedToScreenSize) ? Handler.ScreenSizeCoord.height : this.height_; }\r\n    set height(height) { this.height_ = height; }\r\n    /**\r\n     * Resets within to undefined values\r\n     */\r\n    reset() { this.x = this.y = this.width = this.height = undefined; }\r\n    ;\r\n}\r\n/**\r\n * Coord\r\n */\r\nclass Coord extends Base {\r\n    constructor(...Arguments) {\r\n        super();\r\n        _x_.set(this, void 0);\r\n        _y_.set(this, void 0);\r\n        _width_.set(this, void 0);\r\n        _height_.set(this, void 0);\r\n        /**\r\n         * Within of coord\r\n         */\r\n        this.within = new Within();\r\n        this.buildBase(...Arguments);\r\n        Coord.makeLabel(this);\r\n    }\r\n    get x() { return __classPrivateFieldGet(this, _x_) + ((this.offset) ? this.offset.x : 0); }\r\n    set x(x) { if (!this.frozen)\r\n        __classPrivateFieldSet(this, _x_, x); }\r\n    get y() { return __classPrivateFieldGet(this, _y_) + ((this.offset) ? this.offset.y : 0); }\r\n    set y(y) { if (!this.frozen)\r\n        __classPrivateFieldSet(this, _y_, y); }\r\n    get width() { return __classPrivateFieldGet(this, _width_) + ((this.offset) ? this.offset.width : 0); }\r\n    set width(width) { if (!this.frozen)\r\n        __classPrivateFieldSet(this, _width_, width); }\r\n    get height() { return __classPrivateFieldGet(this, _height_) + ((this.offset) ? this.offset.height : 0); }\r\n    set height(height) { if (!this.frozen)\r\n        __classPrivateFieldSet(this, _height_, height); }\r\n    /**\r\n     * Gets x2 (Read Only)\r\n     */\r\n    get x2() { return this.x + this.width; }\r\n    /**\r\n     * Gets y2 (Read Only)\r\n     */\r\n    get y2() { return this.y + this.height; }\r\n    /**\r\n     * Sets offset (x=0, y=0, width=0, height=0)\r\n     */\r\n    setOffset(x = 0, y = 0, width = 0, height = 0) {\r\n        if (x == 0 && y == 0 && width == 0 && height == 0)\r\n            this.offset = undefined;\r\n        else\r\n            this.offset = { x, y, width, height };\r\n    }\r\n    /**\r\n     * Merges parent Within with this Within (to see if part goes off-screen)\r\n     * @param p Coord Object\r\n     */\r\n    mergeWithin(p /* parent Coord */) {\r\n        if (!this.frozen) {\r\n            let ax1 = p.x, ax2 = p.x + p.width, ay1 = p.y, ay2 = p.y + p.height;\r\n            let bx1 = p.within.x, bx2 = bx1 + p.within.width, by1 = p.within.y, by2 = by1 + p.within.height;\r\n            this.within.x = (ax1 > bx1) ? ax1 : bx1;\r\n            this.within.width = (ax2 < bx2) ? ax2 - this.within.x : bx2 - this.within.x;\r\n            this.within.y = (ay1 > by1) ? ay1 : by1;\r\n            this.within.height = (ay2 < by2) ? ay2 - this.within.y : by2 - this.within.y;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Applys margins (left:number = 0, right:number = 0, top:number =0, bottom:number =0)\r\n     * @returns\r\n     */\r\n    applyMargins(left = 0, right = 0, top = 0, bottom = 0) {\r\n        this.x += left;\r\n        this.y += top;\r\n        this.width -= (left + right);\r\n        this.height -= (top + bottom);\r\n        return this;\r\n    }\r\n    /**\r\n     * Assigns coord (x, y, width, height, wx, wy, wwidth, wheight, zindex)\r\n     * Used for assigning a \"New Coord Root\"\r\n     */\r\n    assign(x = undefined, y = undefined, width = undefined, height = undefined, wx = undefined, wy = undefined, wwidth = undefined, wheight = undefined, zindex = undefined) {\r\n        if (!this.frozen) {\r\n            if (x != undefined)\r\n                this.x = x;\r\n            if (y != undefined)\r\n                this.y = y;\r\n            if (width != undefined)\r\n                this.width = width;\r\n            if (height != undefined)\r\n                this.height = height;\r\n            if (wx != undefined)\r\n                this.within.x = wx;\r\n            if (wy != undefined)\r\n                this.within.y = wy;\r\n            if (wwidth != undefined)\r\n                this.within.width = wwidth;\r\n            if (wheight != undefined)\r\n                this.within.height = wheight;\r\n            if (zindex != undefined)\r\n                this.zindex = zindex;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Copys coord (and uses their 'within', and applies child co-ordinates)\r\n     * @param (fromCoord,  x, y, width, height, zindex)\r\n     * @returns\r\n     */\r\n    copy(fromCoord, x = undefined, y = undefined, width = undefined, height = undefined, zindex = undefined) {\r\n        if (!this.frozen) {\r\n            let noX = (x == undefined);\r\n            this.zindex = (zindex == undefined) ? fromCoord.zindex : zindex;\r\n            this.x = noX ? fromCoord.x : x;\r\n            this.y = noX ? fromCoord.y : y;\r\n            this.width = noX ? fromCoord.width : width;\r\n            this.height = noX ? fromCoord.height : height;\r\n            if (noX) {\r\n                this.within.x = fromCoord.within.x;\r\n                this.within.y = fromCoord.within.y;\r\n                this.within.width = fromCoord.within.width;\r\n                this.within.height = fromCoord.within.height;\r\n            }\r\n            else\r\n                this.mergeWithin(fromCoord);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Logs coord\r\n     */\r\n    log() {\r\n        console.log(`x=${this.x}`, `y=${this.y}`, `width=${this.width}`, `height=${this.height}`);\r\n        console.log(`wx=${this.within.x}`, `wy=${this.within.y}`, `wwidth=${this.within.width}`, `wheight=${this.within.height}`);\r\n    }\r\n    /**\r\n     * Determines whether coord completely outside is\r\n     * if true, de-render, rather than render.\r\n     * @param WITHIN or Coord\r\n     * @returns boolean\r\n     */\r\n    isCoordCompletelyOutside(WITHIN = this.within) {\r\n        return ((WITHIN.x + WITHIN.width < this.x) ||\r\n            (WITHIN.x > this.x + this.width) ||\r\n            (WITHIN.y + WITHIN.height < this.y) ||\r\n            (WITHIN.y > this.y + this.height));\r\n    }\r\n    /**\r\n     * Derenders - if was already derender, or completly outside, then derender.\r\n     * @param derender\r\n     * @returns boolean\r\n     */\r\n    derender(derender) { return derender || this.isCoordCompletelyOutside(); }\r\n    /**\r\n     * Determines whether point is in Coord\r\n     * @param (x, y)\r\n     * @returns true if point whithin Coord.\r\n     */\r\n    isPointIn(x, y) { return (this.x <= x && x <= this.x + this.width && this.y <= y && y <= this.y + this.height); }\r\n    /**\r\n     * Red coord - used for de-bugging - Renders a Coord \"Red\"\r\n     * @param [id]\r\n     */\r\n    red(id = \"red\") {\r\n        let div = document.getElementById(id);\r\n        if (!div) {\r\n            div = document.createElement(\"div\");\r\n            Element_.setAttrib(div, \"id\", id);\r\n            Element_.setAttrib(div, \"llm\", \"\");\r\n            document.body.appendChild(div);\r\n        }\r\n        div.style.cssText = `background:red;left: ${this.x}px; top: ${this.y}px; width: ${this.width}px; height: ${this.height}px; z-index: 1000;`; //style=\"left: 559px; top: 25px; width: 300px; height: 829px; z-index: 30;\"\r\n    }\r\n}\r\n_x_ = new WeakMap(), _y_ = new WeakMap(), _width_ = new WeakMap(), _height_ = new WeakMap();\r\n/**\r\n * Instances of coord object (Key = label)\r\n */\r\nCoord.instances = [];\r\n/**\r\n * Active instances of coord (Not Implemented)\r\n */\r\nCoord.activeInstances = [];\r\n/**\r\n * Defaults of coord\r\n */\r\nCoord.defaults = { x: 0, y: 0, width: 0, height: 0, zindex: 0 };\r\n/**\r\n * Arg map of coord: for example:\r\n * instance.label = first string argument\r\n * instance.x , y, width, height, zindex = first though fifth arguments\r\n * instance.hidewidth = first boolean argument\r\n */\r\nCoord.argMap = {\r\n    string: [\"label\"],\r\n    number: [\"x\", \"y\", \"width\", \"height\", \"zindex\"],\r\n    boolean: [\"hideWidth\"]\r\n};\r\nfunction events(object_) { return { processEvents: object_ }; }\r\n/**\r\n * Element\r\n */\r\nclass Element_ extends Component {\r\n    /**\r\n     * Creates an instance of element .\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.events = {};\r\n        this.attributes = { llm: \"\" };\r\n        this.buildBase(...Arguments);\r\n        Element_.makeLabel(this);\r\n        Element_.instances[this.label] = this;\r\n        this.attributes.id = this.label;\r\n        if (this.Css)\r\n            this.css = this.Css.classname;\r\n        let el = Element_.elExists(this.label);\r\n        // console.log(this.label, el)\r\n        if (el)\r\n            this.loadElement(el);\r\n        if (this.processEvents) {\r\n            this.addEvents(this.processEvents);\r\n        }\r\n    }\r\n    get dim() { return (this.parentDisplayCell) ? this.parentDisplayCell.dim : this.dim_; }\r\n    ;\r\n    set dim(value) {\r\n        if (this.parentDisplayCell)\r\n            this.parentDisplayCell.dim = value;\r\n        else\r\n            this.dim_ = value;\r\n    }\r\n    get css() {\r\n        if (this.Css)\r\n            return this.Css.classname;\r\n        if (this.css_)\r\n            return this.css_;\r\n        return undefined;\r\n    }\r\n    set css(value) {\r\n        this.css_ = value;\r\n        this.attributes.class = value;\r\n    }\r\n    get coord() { if (this.parentDisplayCell)\r\n        return this.parentDisplayCell.coord; return undefined; }\r\n    /**\r\n     * Loads element\r\n     * @param el\r\n     */\r\n    loadElement(el) {\r\n        this.el = el;\r\n        this.attributes = Element_.getAttribs(el);\r\n        this.attributes[\"llm\"] = \"\";\r\n        this.innerHTML = el.innerHTML;\r\n        // console.log(\"loading Element\", el)\r\n        el.remove();\r\n    }\r\n    /**\r\n     * Applys events\r\n     */\r\n    applyEvents() { for (let key in this.events)\r\n        this.el[key] = this.events[key]; }\r\n    /**\r\n     * Adds events\r\n     * @param eventObject\r\n     */\r\n    addEvents(eventObject) {\r\n        for (const key in eventObject) {\r\n            if (key in Element_.customEvents)\r\n                this.addEvents(Element_.customEvents[key](eventObject[key]));\r\n            else\r\n                this.events[key] = FunctionStack.push(this.events[key], eventObject[key]);\r\n        }\r\n    }\r\n    /**\r\n     * Renders html attributes\r\n     */\r\n    renderHtmlAttributes() { for (let key in this.attributes)\r\n        Element_.setAttrib(this.el, key, this.attributes[key]); }\r\n    /**\r\n     * Determines whether connect on\r\n     */\r\n    onConnect() {\r\n        if (this.dim_) {\r\n            this.parentDisplayCell.dim = this.dim_;\r\n            this.dim_ = undefined;\r\n        }\r\n        if (this.retArgs[\"number\"])\r\n            DisplayCell.marginAssign(this.parentDisplayCell, this.retArgs[\"number\"]);\r\n    }\r\n    /**\r\n     * Renders element\r\n     * @param derender\r\n     * @param node\r\n     * @returns\r\n     */\r\n    Render(derender, node) {\r\n        let el = Element_.elExists(this.label);\r\n        if (derender || this.coord.width <= 0) {\r\n            if (el)\r\n                el.remove();\r\n            return [];\r\n        }\r\n        if (!this.el)\r\n            this.el = document.createElement(\"div\");\r\n        if (!el)\r\n            document.body.appendChild(this.el);\r\n        if (this.innerHTML && (!this.ignoreInner) && this.innerHTML != this.el.innerHTML) {\r\n            let newinner = this.evalInner(this);\r\n            if (newinner != undefined)\r\n                this.el.innerHTML = newinner;\r\n        }\r\n        this.renderHtmlAttributes();\r\n        this.applyEvents();\r\n        let styleString = Element_.style(this);\r\n        if (this.el.style.cssText != styleString)\r\n            this.el.style.cssText = styleString;\r\n        return [];\r\n    }\r\n    /**\r\n     * Sets as selected\r\n     */\r\n    setAsSelected() {\r\n        if (!this.attributes.class.endsWith(\"Selected\")) {\r\n            this.attributes.class += \"Selected\";\r\n            if (this.el)\r\n                Element_.setAttrib(this.el, \"class\", this.attributes.class);\r\n        }\r\n    }\r\n    /**\r\n     * Sets as un selected\r\n     */\r\n    setAsUnSelected() {\r\n        if (this.attributes.class.endsWith(\"Selected\")) {\r\n            this.attributes.class = this.attributes.class.slice(0, -8);\r\n            if (this.el)\r\n                Element_.setAttrib(this.el, \"class\", this.attributes.class);\r\n        }\r\n    }\r\n    /**\r\n     * Clips style string\r\n     * @param element\r\n     * @returns\r\n     */\r\n    static clipStyleString(element) {\r\n        let COORD = element.coord;\r\n        let WITHIN = element.coord.within;\r\n        let returnString = \"\";\r\n        let left = (COORD.x < WITHIN.x) ? (WITHIN.x - COORD.x) : 0;\r\n        let right;\r\n        if (COORD.hideWidth) {\r\n            let el = document.getElementById(element.label);\r\n            let bound = el.getBoundingClientRect();\r\n            right = (COORD.x + bound.width > WITHIN.x + WITHIN.width) ? (COORD.x + bound.width - (WITHIN.x + WITHIN.width)) : 0;\r\n        }\r\n        else\r\n            right = (COORD.x + COORD.width > WITHIN.x + WITHIN.width) ? (COORD.x + COORD.width - (WITHIN.x + WITHIN.width)) : 0;\r\n        let top = (COORD.y < WITHIN.y) ? (WITHIN.y - COORD.y) : 0;\r\n        let bottom = (COORD.y + COORD.height > WITHIN.y + WITHIN.height) ? (COORD.y + COORD.height - (WITHIN.y + WITHIN.height)) : 0;\r\n        if (left + right + top + bottom > 0)\r\n            returnString = `clip-path: inset(${top}px ${right}px ${bottom}px ${left}px);`;\r\n        return returnString;\r\n    }\r\n    /**\r\n     * Styles element\r\n     * @param element\r\n     * @returns style\r\n     */\r\n    static style(element) {\r\n        let coord = element.coord;\r\n        let clip = Element_.clipStyleString(element);\r\n        let returnString = `left:${coord.x}px;top:${coord.y}px;`\r\n            + `${(coord.hideWidth || coord.width == undefined) ? \"\" : \"width:\" + coord.width + \"px;\"}`\r\n            + `height:${coord.height}px;z-index:${coord.zindex};${(clip) ? clip + \";\" : \"\"}`\r\n            + ((element.attributes.style) ? element.attributes.style : \"\");\r\n        return returnString;\r\n    }\r\n    /**\r\n     * Gets attribs\r\n     * @param el\r\n     * @param [retObj]\r\n     * @returns attribs\r\n     */\r\n    static getAttribs(el, retObj = {}) {\r\n        for (let i = 0; i < el.attributes.length; i++)\r\n            if (Element_.attribFilter.indexOf(el.attributes[i].name) == -1)\r\n                retObj[el.attributes[i].name] = el.attributes[i].value;\r\n        return retObj;\r\n    }\r\n    /**\r\n     * exists\r\n     * @param id_label\r\n     * @returns\r\n     */\r\n    static elExists(id_label) { return document.getElementById(id_label); }\r\n    /**\r\n     * Sets attribs\r\n     * @param element\r\n     */\r\n    static setAttribs(element) {\r\n        for (const key in element.attributes)\r\n            Element_.setAttrib(element.el, key, element.attributes[key]);\r\n    }\r\n    /**\r\n     * Sets attrib\r\n     * @param el\r\n     * @param attrib\r\n     * @param value\r\n     */\r\n    static setAttrib(el, attrib, value) {\r\n        let prevAttrib = el.getAttribute(attrib);\r\n        if (prevAttrib != value) {\r\n            let att = document.createAttribute(attrib);\r\n            att.value = value;\r\n            el.setAttributeNode(att);\r\n        }\r\n    }\r\n}\r\nElement_.eventsArray = [];\r\nElement_.labelNo = 0;\r\nElement_.instances = {};\r\nElement_.activeInstances = {};\r\nElement_.defaults = { evalInner: (THIS) => THIS.innerHTML };\r\nElement_.argMap = {\r\n    string: [\"label\", \"innerHTML\", \"css_\"],\r\n    dim: [\"dim_\"],\r\n    Css: [\"Css\"],\r\n    function: [\"evalInner\"],\r\n};\r\n/**\r\n * Custom events of element\r\n */\r\nElement_.customEvents = {};\r\n/**\r\n * Attrib filter of element\r\n */\r\nElement_.attribFilter = [\"id\"];\r\nfunction I(...Arguments) { return new DisplayCell(new Element_(...Arguments)); }\r\n/**\r\n * Display cell houses all the Componenets within a Coord (div)\r\n * It can have multiple children.  All Components must be withing a DisplayCell\r\n */\r\nclass DisplayCell extends Component {\r\n    /**\r\n     * Creates an instance of display cell.\r\n     * Arguments are first string = label, and object to become children.\r\n     * usually, you will use displaycellInstance.addComponent()\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.children = [];\r\n        this.buildBase(...Arguments);\r\n        if (!this.coord)\r\n            this.coord = new Coord();\r\n        if (this.retArgs[\"number\"])\r\n            DisplayCell.marginAssign(this, this.retArgs[\"number\"]);\r\n        for (let index = 0; index < Arguments.length; index++) {\r\n            const component = Arguments[index];\r\n            if (typeof (component) == \"object\" && component.constructor) {\r\n                if (component.constructor.name == \"Coord\")\r\n                    this.coord = component;\r\n                else\r\n                    this.addComponent(component);\r\n            }\r\n        }\r\n        if (!this.label)\r\n            DisplayCell.makeLabel(this);\r\n        DisplayCell.instances[this.label] = this;\r\n    }\r\n    set dim(value) { this.setdim(value); }\r\n    get dim() { return this.getdim(); }\r\n    /**\r\n     * Adds component to children of DisplayCell, and runs onConnect()\r\n     */\r\n    addComponent(component) {\r\n        DisplayCell.objectTypes.add(component.constructor.name);\r\n        this.children.push(component);\r\n        component.parentDisplayCell = this;\r\n        component.onConnect();\r\n        if (!this.label)\r\n            this.label = component.label;\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets component from the Children of DisplayCell\r\n     * @param type ie Element_, DisplayGroup\r\n     * @param label of above type, in cases of multiple similar types in children\r\n     */\r\n    getComponent(type, label = undefined) {\r\n        for (let index = 0; index < this.children.length; index++) {\r\n            const component = this.children[index];\r\n            if (Arguments_.typeof(component) == type) {\r\n                if (!label)\r\n                    return component;\r\n                if (label == component[\"label\"])\r\n                    return component;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Deletes component from DisplayCell Children\r\n     */\r\n    deleteComponent(type, label = undefined) {\r\n        let returnValue = false;\r\n        for (let index = 0; index < this.children.length; index++) {\r\n            const component = this.children[index];\r\n            if ((Arguments_.typeof(component) == type) && (!label || label == component[\"label\"])) {\r\n                component[\"parentDisplayCell\"] = undefined;\r\n                this.children.splice(index--, 1);\r\n                returnValue = true;\r\n            }\r\n        }\r\n        return returnValue;\r\n    }\r\n    /**\r\n     * Pre render phase is identical to Render, but gives you an oppotunity\r\n     * to change the parent DisplayCells, before they are rendered\r\n     */\r\n    preRender(derender, node, zindex) {\r\n        let returnArray = [];\r\n        for (let index = 0; index < this.children.length; index++) {\r\n            let component = this.children[index];\r\n            let type = Arguments_.typeof(component);\r\n            if (type != \"DisplayCell\") {\r\n                let temp = component.preRender(derender, node, zindex);\r\n                if (temp)\r\n                    returnArray.concat(temp);\r\n            }\r\n        }\r\n        return returnArray;\r\n    }\r\n    /**\r\n     * Renders objects and expects a return array of children of this object to be rendered.\r\n     * It is at this point that the co-ordinates of the children are set.\r\n     */\r\n    Render(derender = false, node, zindex) {\r\n        this.coord.applyMargins(this.marginLeft, this.marginRight, this.marginTop, this.marginBottom);\r\n        if (this.coord.zindex < 0)\r\n            this.coord.zindex *= -1;\r\n        else\r\n            this.coord.zindex = zindex;\r\n        return this.children;\r\n    }\r\n    /**\r\n     * Adds events to expected child Element_\r\n     */\r\n    addEvents(Argument) {\r\n        let element_ = this.getComponent(\"Element_\");\r\n        if (element_)\r\n            element_.addEvents(Argument);\r\n    }\r\n    /**\r\n     * Sets Margins, in different ways depending on number of arguments.\r\n     * if one, all set to that value, if two, left and right to first, top and bottom to second,\r\n     * if 4, left, right, top, bottom set to those values\r\n     */\r\n    static marginAssign(cell, numberArray) {\r\n        switch (numberArray.length) {\r\n            case 1:\r\n                cell.marginLeft = cell.marginRight = cell.marginTop = cell.marginBottom = numberArray[0];\r\n                break;\r\n            case 2:\r\n                cell.marginLeft = cell.marginRight = numberArray[0];\r\n                cell.marginTop = cell.marginBottom = numberArray[1];\r\n                break;\r\n            case 4:\r\n                cell.marginLeft = numberArray[0];\r\n                cell.marginRight = numberArray[1];\r\n                cell.marginTop = numberArray[2];\r\n                cell.marginBottom = numberArray[3];\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}\r\nDisplayCell.labelNo = 0;\r\n/**\r\n * Instances of display cell as object key=label of DisplayCell\r\n */\r\nDisplayCell.instances = {};\r\nDisplayCell.activeInstances = {};\r\nDisplayCell.defaults = { getdim: function () { return this.dim_; }, setdim: function (value) { this.dim_ = value; } };\r\nDisplayCell.argMap = {\r\n    string: [\"label\"],\r\n};\r\nDisplayCell.objectTypes = new Set();\r\n/**\r\n * Display group Objects stores an Array of children to be\r\n * rendered in either a column (vertical) or row (horizontal)\r\n */\r\nclass DisplayGroup extends Component {\r\n    /**\r\n     * Creates an instance of display group.\r\n     * first string argument is label,\r\n     * first number argument is number of pixels between cells\r\n     * optional \"dim\" value expected (ends with \"px\" or \"%\")\r\n     * if new DisplayGroup() - first boolean true = horizontal, false = vertical\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.children = [];\r\n        this.buildBase(...Arguments);\r\n        DisplayGroup.makeLabel(this);\r\n        DisplayGroup.instances[this.label] = this;\r\n        DisplayGroup.instances[this.label] = this;\r\n        if (\"DisplayCell\" in this.retArgs)\r\n            this.children = this.retArgs[\"DisplayCell\"];\r\n    }\r\n    get dim() { return this.dim_; }\r\n    ;\r\n    set dim(value) { this.dim_ = value; }\r\n    get coord() { return (this.parentDisplayCell) ? this.parentDisplayCell.coord : undefined; }\r\n    /**\r\n     * This is called by the parent when it finds this child.\r\n     * Parent retrieves \"dim\" value of this, and copies Margins.\r\n     */\r\n    onConnect() {\r\n        let THIS = this;\r\n        this.parentDisplayCell.getdim = function () { return THIS.dim; };\r\n        this.parentDisplayCell.setdim = function (value) { THIS.dim = value; };\r\n        if (this.retArgs[\"number\"] && this.retArgs[\"number\"].length > 1)\r\n            DisplayCell.marginAssign(this.parentDisplayCell, this.retArgs[\"number\"].slice(1));\r\n    }\r\n    ;\r\n    /**\r\n     * Renders Displaygroup (Called during Render Phase)\r\n     * (derender:boolean, node:node_, zindex:number)\r\n     */\r\n    Render(derender, node, zindex) {\r\n        // console.log(\"Render\")\r\n        let TotalPixels = ((this.isHor) ? this.coord.width : this.coord.height) - (this.children.length - 1) * ((this.margin) ? this.margin : 0);\r\n        let answersArray = [];\r\n        let totalPxUsed = 0;\r\n        let percentUsed = 0;\r\n        let emptyDim = 0;\r\n        // first pass fills in stuff\r\n        for (let index = 0; index < this.children.length; index++) {\r\n            let child = this.children[index];\r\n            let dim = child.dim;\r\n            let min = (child.min) ? child.min : 0;\r\n            if (dim) {\r\n                if (dim.endsWith(\"px\")) {\r\n                    let px = pf.pxAsNumber(dim);\r\n                    if (px < min)\r\n                        px = min;\r\n                    answersArray.push({ px, percent: 0, min });\r\n                    totalPxUsed += px;\r\n                }\r\n                else {\r\n                    let percent = pf.percentAsNumber(dim);\r\n                    answersArray.push({ px: undefined, percent, min });\r\n                    percentUsed += percent;\r\n                }\r\n            }\r\n            else {\r\n                answersArray.push({ px: undefined, percent: undefined, min });\r\n                ++emptyDim;\r\n            }\r\n        }\r\n        // second pass fills in empty\r\n        if (emptyDim) {\r\n            for (let index = 0; index < answersArray.length; index++)\r\n                if (answersArray[index].percent == undefined)\r\n                    answersArray[index].percent = pf.decimalPlaces((100 - percentUsed) / emptyDim, 2);\r\n        }\r\n        // third pass evaluates percents\r\n        let pixelsLeft = TotalPixels - totalPxUsed;\r\n        for (let index = 0; index < answersArray.length; index++) {\r\n            let aA = answersArray[index];\r\n            if (aA.percent)\r\n                aA.px = pf.decimalPlaces((aA.percent / 100) * pixelsLeft, 1);\r\n        }\r\n        let morePixels = DisplayGroup.forceMin(answersArray);\r\n        let pixelsAvailable = (this.isHor) ? this.coord.width : this.coord.height;\r\n        let margin = ((this.margin == undefined) ? 0 : this.margin);\r\n        let pixelsUsed = 0;\r\n        for (let index = 0; index < answersArray.length; index++) {\r\n            let px = answersArray[index].px;\r\n            pixelsUsed += px + ((index == 0) ? 0 : margin);\r\n        }\r\n        if ((\"ScrollBar\" in Render.classes) && this.allowScrollBar) {\r\n            if (pixelsUsed > pixelsAvailable + 1) {\r\n                if (!this.scrollbar) {\r\n                    this.scrollbar = scrollbar(this.label + \"_ScrollBar\", this.isHor);\r\n                    this.parentDisplayCell.addComponent(this.scrollbar);\r\n                }\r\n                this.offset = this.scrollbar.update(pixelsUsed, pixelsAvailable);\r\n            }\r\n            else {\r\n                if (this.scrollbar) {\r\n                    this.scrollbar.delete();\r\n                    this.parentDisplayCell.deleteComponent(\"ScrollBar\");\r\n                    this.scrollbar = undefined;\r\n                }\r\n            }\r\n        }\r\n        let x = this.coord.x - ((this.isHor) ? this.offset : 0);\r\n        let y = this.coord.y - ((this.isHor) ? 0 : this.offset);\r\n        let width;\r\n        let height;\r\n        for (let index = 0; index < answersArray.length; index++) {\r\n            let px = answersArray[index].px;\r\n            width = (this.isHor) ? px : this.coord.width;\r\n            height = (this.isHor) ? this.coord.height : px;\r\n            this.children[index].coord.copy(this.coord, x, y, width, height, zindex);\r\n            x += (this.isHor) ? width + margin : 0;\r\n            y += (this.isHor) ? 0 : height + margin;\r\n        }\r\n        return this.children;\r\n    }\r\n    /**\r\n     * Forces min\r\n     * @param answersArray\r\n     * @returns\r\n     */\r\n    static forceMin(answersArray) {\r\n        let morePixels = 0;\r\n        let totalPercent = 0;\r\n        for (let index = 0; index < answersArray.length; index++) {\r\n            let aA = answersArray[index];\r\n            if (aA.px < aA.min) {\r\n                morePixels += aA.min - aA.px;\r\n                aA.px = aA.min;\r\n                if (aA.percent) {\r\n                    aA.percent = undefined;\r\n                }\r\n            }\r\n            if (aA.percent)\r\n                totalPercent += aA.percent;\r\n        }\r\n        if (totalPercent < 99 && totalPercent > 0) {\r\n            let scaleFactor = 100 / totalPercent;\r\n            for (let index = 0; index < answersArray.length; index++) {\r\n                let aA = answersArray[index];\r\n                if (aA.percent)\r\n                    aA.percent = pf.decimalPlaces(aA.percent * scaleFactor, 2);\r\n            }\r\n        }\r\n        return morePixels;\r\n    }\r\n}\r\nDisplayGroup.labelNo = 0;\r\nDisplayGroup.instances = {};\r\nDisplayGroup.activeInstances = {};\r\nDisplayGroup.defaults = { isHor: true, margin: 0, offset: 0 };\r\nDisplayGroup.argMap = {\r\n    string: [\"label\"],\r\n    number: [\"margin\"],\r\n    dim: [\"dim_\"],\r\n    boolean: [\"isHor\"],\r\n};\r\nfunction h(...Arguments) { return new DisplayCell(new DisplayGroup(...Arguments)); }\r\nfunction v(...Arguments) { return h(false, ...Arguments); }\r\n/**\r\n * Handler\r\n */\r\nclass Handler extends Component {\r\n    /**\r\n     * Creates an instance of handler.\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.children = [];\r\n        this.buildBase(...Arguments);\r\n        Handler.makeLabel(this);\r\n        Handler.instances[this.label] = this;\r\n        for (let index = 0; index < Arguments.length; index++) {\r\n            const newChildObject = Arguments[index];\r\n            if (typeof (newChildObject) == \"object\" && newChildObject.constructor) {\r\n                if (newChildObject.constructor.name == \"Coord\")\r\n                    this.coord = newChildObject;\r\n                else {\r\n                    DisplayCell.objectTypes.add(newChildObject.constructor.name);\r\n                    this.children.push(newChildObject);\r\n                }\r\n            }\r\n        }\r\n        if (!this.coord)\r\n            this.coord = Handler.ScreenSizeCoord;\r\n        if (this.startRendered)\r\n            Handler.activeInstances[this.label] = this;\r\n    }\r\n    /**\r\n     * Links handlers\r\n     */\r\n    static linkHandlers() {\r\n        let links = document.querySelectorAll(\"[handler]\");\r\n        Handler.linkHandlerOldList = Handler.linkHandlerNewList;\r\n        Handler.linkHandlerNewList = [];\r\n        for (let index = 0; index < links.length; index++) {\r\n            const el = links[index];\r\n            let parentEl = el;\r\n            do {\r\n                parentEl = parentEl.parentElement;\r\n            } while (!(parentEl.id && Element_.instances[parentEl.id]) && (parentEl));\r\n            let coord = (parentEl) ? Element_.instances[parentEl.id].parentDisplayCell.coord : Handler.ScreenSizeCoord;\r\n            let handlerLabel = el.getAttribute(\"handler\");\r\n            let handler = Handler.instances[handlerLabel];\r\n            if (handler) {\r\n                if (!Handler.activeInstances[handlerLabel])\r\n                    Handler.activeInstances[handlerLabel] = handler;\r\n                if (Handler.linkHandlerNewList.indexOf(handler) == -1)\r\n                    Handler.linkHandlerNewList.push(handler);\r\n                if (!handler.preRenderCallBack) {\r\n                    handler.preRenderCallBack = FunctionStack.push(undefined, function setHandlerCoord(handler) {\r\n                        let { x, y, width, height } = el.getBoundingClientRect();\r\n                        handler.coord.copy(coord, x, y, width, height);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        for (let index = 0; index < Handler.linkHandlerOldList.length; index++) {\r\n            let handler = Handler.linkHandlerOldList[index];\r\n            if (Handler.linkHandlerNewList.indexOf(handler) == -1) {\r\n                delete handler.preRenderCallBack;\r\n                Render.update(handler.parentDisplayCell, true);\r\n                delete Handler.activeInstances[handler.label];\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Updates screen size coord\r\n     */\r\n    static updateScreenSizeCoord() {\r\n        let win = window, doc = document, docElem = doc.documentElement, body = doc.getElementsByTagName('body')[0], x = win.innerWidth || docElem.clientWidth || body.clientWidth, y = win.innerHeight || docElem.clientHeight || body.clientHeight;\r\n        Handler.ScreenSizeCoord.frozen = false;\r\n        Handler.ScreenSizeCoord.assign(0, 0, x, y, 0, 0, x, y);\r\n        Handler.ScreenSizeCoord.frozen = true;\r\n    }\r\n    /**\r\n     * Gets handlers\r\n     * @returns handlers\r\n     */\r\n    static getHandlers() {\r\n        let objectArray = [];\r\n        for (const key in Handler.activeInstances)\r\n            objectArray.push(Handler.activeInstances[key].parentDisplayCell);\r\n        return objectArray;\r\n    }\r\n    /**\r\n     * Determines whether connect on\r\n     */\r\n    onConnect() {\r\n        if (this.retArgs[\"number\"] && this.retArgs[\"number\"].length >= 1)\r\n            DisplayCell.marginAssign(this.parentDisplayCell, this.retArgs[\"number\"]);\r\n        if (this.startRendered)\r\n            Render.scheduleUpdate();\r\n    }\r\n    /**\r\n     * Pre render\r\n     * @param derender\r\n     * @param node\r\n     */\r\n    preRender(derender, node) {\r\n        if (this.preRenderCallBack)\r\n            this.preRenderCallBack(this);\r\n        this.parentDisplayCell.coord.copy(this.coord);\r\n    }\r\n    /**\r\n     * Renders handler\r\n     * @param derender\r\n     * @param node\r\n     * @param zindex\r\n     * @returns render\r\n     */\r\n    Render(derender, node, zindex) {\r\n        for (let index = 0; index < this.children.length; index++)\r\n            (this.children[index]).coord.copy(this.parentDisplayCell.coord);\r\n        if (this.postRenderCallBack)\r\n            this.postRenderCallBack(this);\r\n        return this.children;\r\n    }\r\n    /**\r\n     * Shows handler\r\n     */\r\n    show() { Handler.activeInstances[this.label] = this; Render.scheduleUpdate(); }\r\n    /**\r\n     * Hides handler\r\n     */\r\n    hide() {\r\n        Render.update(this.parentDisplayCell, true);\r\n        delete Handler.activeInstances[this.label];\r\n    }\r\n}\r\nHandler.labelNo = 0;\r\nHandler.instances = {};\r\nHandler.activeInstances = {};\r\nHandler.defaults = { startRendered: true };\r\nHandler.argMap = {\r\n    string: [\"label\"],\r\n    Coord: [\"coord\"],\r\n    boolean: [\"startRendered\"],\r\n    function: [\"preRenderCallBack\", \"postRenderCallBack\"]\r\n};\r\nHandler.linkHandlerOldList = [];\r\nHandler.linkHandlerNewList = [];\r\n/**\r\n * Screen size coord of handler\r\n */\r\nHandler.ScreenSizeCoord = new Coord();\r\nfunction H(...Arguments) { return new DisplayCell(new Handler(...Arguments)); }\r\n/**\r\n * Css - This class is used like a css sheet.\r\n * It stores the data in an object, rather than css sheet\r\n */\r\nclass Css extends Base {\r\n    /**\r\n     * Creates an instance of css.\r\n     * First String is classname, Second is css, third is onhover css, fourth is on Selected\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.buildBase(...Arguments);\r\n        if (this.cssObj == undefined) {\r\n            this.cssObj = this.makeObj();\r\n            this.css = this.makeString();\r\n        }\r\n        if (this.cssHover) {\r\n            this.cssHoverObj = this.makeObj(this.cssHover);\r\n            this.cssHover = this.makeString(this.cssHoverObj, \"hover\");\r\n        }\r\n        if (this.cssSelect) {\r\n            this.cssSelectObj = this.makeObj(this.cssSelect);\r\n            this.cssSelect = this.makeString(this.cssSelectObj, \"\", \"Selected\");\r\n        }\r\n        Css.instances[this.classname] = this;\r\n    }\r\n    /**\r\n     * label\r\n     * @param classname\r\n     * @returns label\r\n     */\r\n    static byLabel(classname) {\r\n        for (let key in Css.instances)\r\n            if (Css.instances[key].classname == classname)\r\n                return Css.instances[key];\r\n        return undefined;\r\n    }\r\n    /**\r\n     * News string\r\n     * @param data\r\n     */\r\n    newString(data) {\r\n        this.cssObj = this.makeObj(data);\r\n        this.css = this.makeString();\r\n    }\r\n    /**\r\n     * Converts Obect to String\r\n     */\r\n    makeString(obj = this.cssObj, postfix = \"\", addToClassName = \"\") {\r\n        let returnString = `${(this.isClassname) ? \".\" : \"\"}${this.classname}${addToClassName}${(postfix) ? \":\" + postfix : \"\"} {\\n`;\r\n        for (let key in obj)\r\n            returnString += `  ${key}:${obj[key]};\\n`;\r\n        returnString += \"}\";\r\n        return returnString;\r\n    }\r\n    /**\r\n     * Makes an object from a css string (within the {} of class definition)\r\n     * @returns obj\r\n     */\r\n    makeObj(str = this.css) {\r\n        //let str = this.asString;\r\n        let obj = {};\r\n        if (str.indexOf('{') > -1) {\r\n            str = str.split('{')[1];\r\n            str = str.split('}')[0];\r\n        }\r\n        let strArray = str.split(';');\r\n        let index;\r\n        let arr;\r\n        for (let ele of strArray) {\r\n            index = ele.indexOf(':');\r\n            if (index > -1) {\r\n                arr = ele.split(':');\r\n                obj[arr[0].trim()] = arr[1].trim();\r\n            }\r\n        }\r\n        return obj;\r\n    }\r\n    /**\r\n     * Updates css Objects in DOM <style id=\"llmstyle\"></style>\r\n     */\r\n    static update() {\r\n        let style = document.getElementById(Css.elementId);\r\n        let alreadyexists = true;\r\n        if (!style) {\r\n            alreadyexists = false;\r\n            style = document.createElement('style');\r\n        }\r\n        Element_.setAttrib(style, \"id\", Css.elementId);\r\n        let outstring = \"\\n\";\r\n        for (const key in Css.instances) {\r\n            const instance = Css.instances[key];\r\n            if (instance.css) {\r\n                outstring += instance.css + \"\\n\";\r\n            }\r\n            if (instance.cssHover) {\r\n                outstring += instance.cssHover + \"\\n\";\r\n            }\r\n            if (instance.cssSelect) {\r\n                outstring += instance.cssSelect + \"\\n\";\r\n            }\r\n        }\r\n        style.innerHTML = outstring;\r\n        if (!alreadyexists)\r\n            document.getElementsByTagName('head')[0].appendChild(style);\r\n    }\r\n}\r\nCss.elementId = \"llmStyle\";\r\nCss.instances = {};\r\nCss.activeInstances = {};\r\nCss.defaults = { isClassname: true };\r\n/**\r\n * Argument map of css\r\n * First String is classname, Second is css, third is onhover css, fourth is on Selected\r\n */\r\nCss.argMap = {\r\n    string: [\"classname\", \"css\", \"cssHover\", \"cssSelect\", \"cssSelectHover\"],\r\n    boolean: [\"isClassname\"]\r\n};\r\n/**\r\n * On First Run, all elements with class = \"remove\", are removed.\r\n */\r\nCss.deleteOnFirstRunClassname = \".remove\";\r\nCss.advisedDiv = new Css(\"div[llm]\", \"position:absolute;\", false, { type: \"llm\" });\r\nCss.advisedBody = new Css(\"body\", \"overflow: auto hidden;\", false, { type: \"llm\" });\r\nCss.advisedHtml = new Css(\"html\", \"overflow: auto hidden;\", false, { type: \"llm\" });\r\nfunction css(...Arguments) { return new Css(...Arguments); }\r\n/**\r\n * Render Object - Renders Components\r\n */\r\nclass Render {\r\n    /**\r\n     * Schedules update - Prefered Method for updating\r\n     */\r\n    static scheduleUpdate() {\r\n        if (Render.firstRun) {\r\n            Render.firstRun = false;\r\n            window.onresize = FunctionStack.push(undefined, function fullupdate(e) { Render.fullupdate(); });\r\n            window.addEventListener('scroll', function () { Render.fullupdate(); }, true);\r\n            window.onwheel = FunctionStack.push(undefined, function fullupdate(e) { Render.fullupdate(); });\r\n            let deletes = document.getElementsByClassName(\"remove\");\r\n            for (let index = 0; index < deletes.length; index++)\r\n                deletes[index].remove();\r\n        }\r\n        if (!Render.pleaseUpdate) {\r\n            Render.pleaseUpdate = true;\r\n            setTimeout(() => {\r\n                Render.pleaseUpdate = false;\r\n                Render.fullupdate();\r\n            }, 0);\r\n        }\r\n    }\r\n    /**\r\n     * Fullupdates render\r\n     * @param [derender]\r\n     */\r\n    static fullupdate(derender = false) {\r\n        Css.update();\r\n        Render.node = new node_(\"Root\");\r\n        Handler.updateScreenSizeCoord();\r\n        Handler.linkHandlers();\r\n        let handlers = Handler.getHandlers();\r\n        let currentNumberOfHandlers = handlers.length;\r\n        for (let index = 0; index < handlers.length; index++) {\r\n            Render.update([handlers[index]], derender, Render.node, index * Render.zindexHandlerIncrement);\r\n        }\r\n    }\r\n    /**\r\n     * Updates render - usually called for de-render\r\n     * update(SomeObject, true);\r\n     * @param [components_]\r\n     * @param [derender]\r\n     * @param [parentNode]\r\n     * @param [zindex]\r\n     */\r\n    static update(components_ = undefined, derender = false, parentNode = undefined, zindex = 0) {\r\n        if (components_) {\r\n            let components;\r\n            if (Arguments_.typeof(components_) != \"Array\")\r\n                components = [components_];\r\n            else\r\n                components = components_;\r\n            let node;\r\n            for (let index = 0; index < components.length; index++) {\r\n                const component = components[index];\r\n                let type = Arguments_.typeof(component);\r\n                if (derender)\r\n                    node = component.node;\r\n                else {\r\n                    node = parentNode.newChild(component.label, component);\r\n                    component.node = node;\r\n                }\r\n                if (type == \"DisplayCell\") {\r\n                    let newObjects = component.preRender(derender, node, zindex);\r\n                    if (newObjects && newObjects.length)\r\n                        Render.update(newObjects, derender, node, zindex + Render.zindexIncrement);\r\n                }\r\n                let newObjects = component.Render(derender, node, zindex);\r\n                if (newObjects && newObjects.length)\r\n                    Render.update(newObjects, derender, node, zindex + Render.zindexIncrement);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Registers render\r\n     * @param label\r\n     * @param object_\r\n     */\r\n    static register(label, object_) { Render.classes[label] = object_; }\r\n}\r\nRender.zindexIncrement = 5;\r\nRender.zindexHandlerIncrement = 100;\r\nRender.pleaseUpdate = false;\r\nRender.firstRun = true;\r\n/**\r\n * Classes of render - Used for determinine what modules are loaded\r\n */\r\nRender.classes = { /* DragBar,for wxample... filled in when modules load. */};\r\nclass ScrollBar extends Component {\r\n    /**\r\n     * Creates an instance of scroll bar.\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.buildBase(...Arguments);\r\n        ScrollBar.makeLabel(this);\r\n        ScrollBar.instances[this.label] = this;\r\n        this.build();\r\n        ScrollBar.instances[this.label] = this;\r\n    }\r\n    static leftArrowSVG(classname) {\r\n        return `<svg class=\"${classname}\" width=\"100%\" height=\"100%\" version=\"1.1\" viewBox=\"-10 -10 45 45\" xmlns=\"http://www.w3.org/2000/svg\">\r\n      <path transform=\"rotate(182.31 12.399 12.341)\" d=\"m21.167 11.793-16.891 10.81-0.91654-20.033 8.9037 4.6114z\" stroke-linecap=\"round\" stroke-width=\".84667\"/>\r\n      </svg>`;\r\n    }\r\n    static rightArrowSVG(classname) {\r\n        return `<svg class=\"${classname}\" width=\"100%\" height=\"100%\" version=\"1.1\" viewBox=\"-10 -10 45 45\" xmlns=\"http://www.w3.org/2000/svg\">\r\n      <path transform=\"rotate(2.382 1.0017 36.146)\" d=\"m21.167 11.793-16.891 10.81-0.91654-20.033 8.9037 4.6114z\" stroke-linecap=\"round\" stroke-width=\".84667\"/>\r\n      </svg>`;\r\n    }\r\n    static upArrowSVG(classname) {\r\n        return `<svg class=\"${classname}\" width=\"100%\" height=\"100%\" version=\"1.1\" viewBox=\"-10 -10 45 45\" xmlns=\"http://www.w3.org/2000/svg\">\r\n      <path transform=\"rotate(-87.663 12.607 12.106)\" d=\"m21.167 11.793-16.891 10.81-0.91654-20.033 8.9037 4.6114z\" stroke-linecap=\"round\" stroke-width=\".84667\"/>\r\n      </svg>`;\r\n    }\r\n    static downArrowSVG(classname) {\r\n        return `<svg class=\"${classname}\" width=\"100%\" height=\"100%\" version=\"1.1\" viewBox=\"-10 -10 45 45\" xmlns=\"http://www.w3.org/2000/svg\">\r\n      <path transform=\"rotate(92.906 12.406 12.398)\" d=\"m21.167 11.793-16.891 10.81-0.91654-20.033 8.9037 4.6114z\" stroke-linecap=\"round\" stroke-width=\".84667\"/>\r\n      </svg>`;\r\n    }\r\n    get scrollbarPixels() {\r\n        let coord = this.scrollbarDisplayCell.coord;\r\n        return (this.isHor) ? coord.width - this.barSize * 2 : coord.height - this.barSize * 2;\r\n    }\r\n    get ratio() {\r\n        return pf.decimalPlaces(this.pixelsUsed / this.scrollbarPixels, 3);\r\n    }\r\n    /**\r\n     * Updates scroll bar\r\n     * @param pixelsUsed\r\n     * @param pixelsAvailable\r\n     * @returns update\r\n     */\r\n    update(pixelsUsed, pixelsAvailable) {\r\n        this.pixelsUsed = pixelsUsed;\r\n        this.pixelsAvailable = pixelsAvailable;\r\n        this.limit();\r\n        return this.offset;\r\n    }\r\n    /**\r\n     * Limits scroll bar\r\n     */\r\n    limit() {\r\n        if (this.offset < 0)\r\n            this.offset = 0;\r\n        if (this.offset > this.pixelsUsed - this.pixelsAvailable)\r\n            this.offset = this.pixelsUsed - this.pixelsAvailable;\r\n    }\r\n    /**\r\n     * Determines whether connect on\r\n     */\r\n    onConnect() {\r\n        this.preRender(undefined, undefined);\r\n        Render.scheduleUpdate();\r\n    }\r\n    ;\r\n    /**\r\n     * Pre render\r\n     * @param derender\r\n     * @param node\r\n     * @returns render\r\n     */\r\n    preRender(derender, node) {\r\n        if (this.isHor)\r\n            this.parentDisplayCell.coord.height -= this.barSize;\r\n        else\r\n            this.parentDisplayCell.coord.width -= this.barSize;\r\n        return undefined;\r\n    }\r\n    ;\r\n    /**\r\n     * Renders scroll bar\r\n     * @param derender\r\n     * @param node\r\n     * @param zindex\r\n     * @returns render\r\n     */\r\n    Render(derender, node, zindex) {\r\n        // console.log(\"Scrollbar Render\");\r\n        let coord = this.parentDisplayCell.coord;\r\n        let x = (this.isHor) ? coord.x : coord.x + coord.width;\r\n        let y = (this.isHor) ? coord.y + coord.height : coord.y;\r\n        let width = (this.isHor) ? coord.width : this.barSize;\r\n        let height = (this.isHor) ? this.barSize : coord.height;\r\n        this.scrollbarDisplayCell.coord.assign(x, y, width, height, x, y, width, height, zindex);\r\n        this.preBar.dim = `${this.offset / this.ratio}px`;\r\n        this.Bar.dim = `${this.scrollbarPixels * this.pixelsAvailable / this.pixelsUsed - 1}px`;\r\n        this.postBar.dim = `100%`;\r\n        return [this.scrollbarDisplayCell];\r\n    }\r\n    ;\r\n    /**\r\n     * Deletes scroll bar\r\n     */\r\n    delete() {\r\n        Render.update(this.scrollbarDisplayCell, true);\r\n        Render.scheduleUpdate();\r\n    }\r\n    /**\r\n     * Builds scroll bar\r\n     */\r\n    build() {\r\n        let label = this.label + ((this.isHor) ? \"_H\" : \"_V\");\r\n        this.preBar = I(`${label}_preBar`, ScrollBar.ScrollBar_whiteBG, events({ onclick: this.onSmallerBar.bind(this) }));\r\n        this.Bar = I(`${label}_Bar`, ScrollBar.ScrollBar_blackBG, events({ ondrag: [this.onBarDown.bind(this), this.onBarMove.bind(this)] }));\r\n        this.postBar = I(`${label}_postBar`, ScrollBar.ScrollBar_whiteBG, events({ onclick: this.onBiggerBar.bind(this) }));\r\n        this.scrollbarDisplayCell =\r\n            h(`${label}_h`, this.isHor, I(`${label}_backArrow`, `${this.barSize}px`, (this.isHor) ? ScrollBar.leftArrowSVG(\"scrollArrows\") : ScrollBar.upArrowSVG(\"scrollArrows\"), events({ onholdclick: [this.onSmallArrow.bind(this)] })), this.preBar, this.Bar, this.postBar, I(`${label}_forwardArrow`, `${this.barSize}px`, (this.isHor) ? ScrollBar.rightArrowSVG(\"scrollArrows\") : ScrollBar.downArrowSVG(\"scrollArrows\"), events({ onholdclick: [this.onBigArrow.bind(this)] })));\r\n    }\r\n    onSmallArrow(e) { this.offset -= this.ratio * this.scrollMultiplier; this.limit(); Render.scheduleUpdate(); }\r\n    onBigArrow(e) { this.offset += this.ratio * this.scrollMultiplier; this.limit(); Render.scheduleUpdate(); }\r\n    onSmallerBar(e) { this.offset -= this.pixelsAvailable; this.limit(); Render.scheduleUpdate(); }\r\n    onBiggerBar(e) { this.offset += this.pixelsAvailable; this.limit(); Render.scheduleUpdate(); }\r\n    onBarDown(e) { ScrollBar.startoffset = this.offset; }\r\n    onBarMove(e, xmouseDiff) {\r\n        let dist = (this.isHor) ? xmouseDiff[\"x\"] : xmouseDiff[\"y\"];\r\n        this.offset = ScrollBar.startoffset + dist * this.ratio;\r\n        this.limit();\r\n        Render.scheduleUpdate();\r\n    }\r\n}\r\nScrollBar.labelNo = 0;\r\nScrollBar.instances = {};\r\nScrollBar.activeInstances = {};\r\nScrollBar.defaults = { barSize: 15, offset: 0, scrollMultiplier: 5 };\r\nScrollBar.argMap = {\r\n    string: [\"label\"],\r\n    boolean: [\"isHor\"],\r\n    //DisplayGroup : [\"parentDisplayGroup\"],\r\n};\r\nScrollBar.ScrollBar_whiteBG = css(\"whiteBG\", \"background-color:white;outline: 1px solid black;outline-offset: -1px;\", { type: \"llm\" });\r\nScrollBar.ScrollBar_blackBG = css(\"blackBG\", \"background-color:black;color:white;cursor: -webkit-grab; cursor: grab;\", { type: \"llm\" });\r\n// arrows  //scrollArrows\r\nScrollBar.scrollArrowsSVGCss = css(`scrollArrows`, `stroke: black;`, `fill: white;`, { type: \"llm\" });\r\nScrollBar.arrowSVGCss = css(`arrowIcon`, `stroke: black;cursor:pointer;`, `fill: white;`, { type: \"llm\" });\r\nRender.register(\"ScrollBar\", ScrollBar);\r\nfunction scrollbar(...Arguments) {\r\n    return new ScrollBar(...Arguments);\r\n}\r\n/**\r\n * On drag\r\n */\r\nclass onDrag_ extends Base {\r\n    /**\r\n     * Creates an instance of on drag .\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.onDown = function () { };\r\n        this.onMove = function () { };\r\n        this.onUp = function () { };\r\n        this.isDown = false;\r\n        this.buildBase(...Arguments);\r\n        if (\"Array\" in this.retArgs) {\r\n            let array = this.retArgs[\"Array\"][0];\r\n            let num = array.length;\r\n            if (num > 0)\r\n                this.onDown = array[0];\r\n            if (num > 1)\r\n                this.onMove = array[1];\r\n            if (num > 2)\r\n                this.onUp = array[2];\r\n        }\r\n        let THIS = this;\r\n        onDrag_.makeLabel(this);\r\n        this.returnObject = {\r\n            onmousedown: function (e) {\r\n                THIS.onDown(e);\r\n                THIS.isDown = true;\r\n                THIS.mousePos = { x: e.clientX, y: e.clientY };\r\n                window.addEventListener('selectstart', onDrag_.disableSelect);\r\n                window.onmousemove = FunctionStack.push(window.onmousemove, function onDragMove(e) {\r\n                    THIS.mouseDiff = { x: e.clientX - THIS.mousePos[\"x\"], y: e.clientY - THIS.mousePos[\"y\"] };\r\n                    THIS.onMove(e, THIS.mouseDiff);\r\n                });\r\n                window.onmouseup = FunctionStack.push(window.onmouseup, function onDragUp(e) {\r\n                    THIS.reset();\r\n                    THIS.onUp(e, THIS.mouseDiff);\r\n                });\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * Resets on drag\r\n     */\r\n    reset() {\r\n        FunctionStack.pop((window.onmousemove), \"onDragMove\");\r\n        FunctionStack.pop((window.onmouseup), \"onDragUp\");\r\n        window.removeEventListener('selectstart', onDrag_.disableSelect);\r\n        this.isDown = false;\r\n    }\r\n    static disableSelect(event) { event.preventDefault(); }\r\n}\r\nonDrag_.instances = [];\r\nonDrag_.activeInstances = [];\r\nonDrag_.defaults = {};\r\nonDrag_.argMap = {\r\n    string: [\"label\"],\r\n    function: [\"onDown\", \"onMove\", \"onUp\"],\r\n};\r\nfunction onDrag(...Arguments) { return (new onDrag_(...Arguments)).returnObject; }\r\nElement_.customEvents[\"ondrag\"] = function (newData) { return onDrag(newData); };\r\n/**\r\n * On hold click\r\n */\r\nclass onHoldClick_ extends Base {\r\n    /**\r\n     * Creates an instance of on hold click .\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.buildBase(...Arguments);\r\n        onHoldClick_.makeLabel(this);\r\n        onHoldClick_.instances[this.label] = this;\r\n        let THIS = this;\r\n        this.returnObject = {\r\n            onmousedown: function (e) {\r\n                THIS.mouseDownEvent = e;\r\n                THIS.onDown(e);\r\n                THIS.isDown = new Date().getTime();\r\n                window.onmouseup = FunctionStack.push(window.onmouseup, function onHoldClickUp(e) {\r\n                    //console.log(\"mouseUp\");\r\n                    FunctionStack.pop((window.onmouseup), \"onHoldClickUp\");\r\n                    THIS.isDown = undefined;\r\n                });\r\n                setTimeout(() => {\r\n                    let newTime = new Date().getTime();\r\n                    // console.log(\"ok\",newTime - THIS.isDown, THIS.initialDelay)\r\n                    if (THIS.isDown && (newTime - THIS.isDown) >= THIS.initialDelay) {\r\n                        THIS.repeat();\r\n                    }\r\n                }, THIS.initialDelay);\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * Repeats on hold click\r\n     */\r\n    repeat() {\r\n        let THIS = this;\r\n        this.FUNCTION(this.mouseDownEvent);\r\n        setTimeout(() => { if (THIS.isDown)\r\n            THIS.repeat(); }, THIS.repeatDelay);\r\n    }\r\n    onDown(e) { this.FUNCTION(e); }\r\n}\r\nonHoldClick_.labelNo = 0;\r\nonHoldClick_.instances = {};\r\nonHoldClick_.activeInstances = {};\r\nonHoldClick_.defaults = { initialDelay: 1000, repeatDelay: 75 };\r\nonHoldClick_.argMap = {\r\n    string: [\"label\"],\r\n    number: [\"initialDelay\", \"repeatDelay\"],\r\n    function: [\"FUNCTION\"],\r\n};\r\nfunction onHoldClick(...Arguments) { return (new onHoldClick_(...Arguments)).returnObject; }\r\nElement_.customEvents[\"onholdclick\"] = function (newData) { return onHoldClick(...newData); };\r\n/**\r\n * Selected\r\n */\r\nclass Selected extends Base {\r\n    /**\r\n     * Creates an instance of selected.\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.buildBase(...Arguments);\r\n        Selected.makeLabel(this);\r\n        this.updateEvents();\r\n        if (this.startValue != undefined)\r\n            this.select(this.startValue);\r\n        Selected.instances[this.label] = this;\r\n    }\r\n    get indexer() { return this.getIndexerArray(this); }\r\n    set indexer(value) { this.indexer_ = value; }\r\n    /**\r\n     * Updates events\r\n     */\r\n    updateEvents() {\r\n        let THIS = this;\r\n        for (let index = 0; index < this.indexer.length; index++) {\r\n            let displayCells;\r\n            let type = Arguments_.typeof(this.indexer[index]);\r\n            if (type == \"DisplayCell\")\r\n                displayCells = this.indexer[index] = [(this.indexer[index])];\r\n            else if (type == \"Array\")\r\n                displayCells = (this.indexer[index]);\r\n            for (let index = 0; index < displayCells.length; index++)\r\n                displayCells[index].addEvents({ onclick: function selected(e) { THIS.select(displayCells[index]); } });\r\n        }\r\n    }\r\n    /**\r\n     * Selects selected\r\n     * @param displaycellOrNumber\r\n     */\r\n    select(displaycellOrNumber) {\r\n        let newIndex;\r\n        let type = Arguments_.typeof(displaycellOrNumber);\r\n        if (type == \"number\")\r\n            newIndex = displaycellOrNumber;\r\n        else if (type == \"DisplayCell\")\r\n            newIndex = this.indexOf(displaycellOrNumber);\r\n        if (newIndex != undefined) {\r\n            if (this.currentButtonIndex != newIndex) {\r\n                if (this.currentButtonIndex != undefined)\r\n                    this.onUnselect(this.currentButtonIndex);\r\n                this.currentButtonIndex = newIndex;\r\n                this.onSelect(this.currentButtonIndex);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Clears selected\r\n     */\r\n    clear() { this.onUnselect(this.currentButtonIndex); this.currentButtonIndex = undefined; }\r\n    /**\r\n     * Indexs of\r\n     * @param displaycell\r\n     * @returns of\r\n     */\r\n    indexOf(displaycell) {\r\n        for (let index = 0; index < this.indexer.length; index++)\r\n            if (this.indexer[index].indexOf(displaycell) > -1)\r\n                return index;\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Determines whether select on\r\n     * @param index\r\n     */\r\n    onSelect(index) {\r\n        // console.log(\"onSelectCalled\", this.indexer)\r\n        let selectArray = (this.indexer[index]);\r\n        for (let i = 0; i < selectArray.length; i++) {\r\n            const displaycell = selectArray[i];\r\n            let element = displaycell.getComponent(\"Element_\");\r\n            if (element)\r\n                element.setAsSelected();\r\n            if (this.onselect)\r\n                this.onselect(index, displaycell);\r\n        }\r\n    }\r\n    /**\r\n     * Determines whether unselect on\r\n     * @param index\r\n     */\r\n    onUnselect(index) {\r\n        let unSelectArray = (this.indexer[index]);\r\n        for (let i = 0; i < unSelectArray.length; i++) {\r\n            const displaycell = unSelectArray[i];\r\n            let element = displaycell.getComponent(\"Element_\");\r\n            if (element)\r\n                element.setAsUnSelected();\r\n            if (this.onunselect)\r\n                this.onunselect(index, displaycell);\r\n        }\r\n    }\r\n}\r\nSelected.labelNo = 0;\r\nSelected.instances = {};\r\nSelected.activeInstances = {};\r\nSelected.defaults = { indexer: [], getIndexerArray: function (selectedInstance) { return selectedInstance.indexer_; } };\r\nSelected.argMap = {\r\n    string: [\"label\"],\r\n    function: [\"onselect\", \"onunselect\"],\r\n    Array: [\"indexer_\"],\r\n    number: [\"startValue\"],\r\n    Pages: [\"pages\"],\r\n};\r\n/**\r\n * Pages\r\n */\r\nclass Pages extends Component {\r\n    // retArgs:objectAny;   // <- this will appear\r\n    /**\r\n     * Creates an instance of pages.\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.buildBase(...Arguments);\r\n        let THIS = this;\r\n        Pages.makeLabel(this);\r\n        Pages.instances[this.label] = this;\r\n        if (\"DisplayCell\" in this.retArgs)\r\n            this.cellArray = this.retArgs[\"DisplayCell\"];\r\n        let index = -1;\r\n        if (this.tree) {\r\n            this.cellArray = [];\r\n            node_.traverse(this.tree.parentTreeNode, function (node) {\r\n                let label = node.Arguments[0];\r\n                let displaycell = DisplayCell.instances[label];\r\n                if (!displaycell)\r\n                    displaycell = I(label);\r\n                let element_ = (node[\"displaycell\"]).getComponent(\"Element_\");\r\n                let i = index;\r\n                element_.addEvents({ onclick: function () { THIS.currentPage = i; } });\r\n                THIS.cellArray.push(displaycell);\r\n                index++;\r\n            });\r\n            this.cellArray.shift();\r\n        }\r\n        Pages.instances[this.label] = this;\r\n    }\r\n    get dim() { return this.dim_; }\r\n    set dim(value) { this.dim_ = value; }\r\n    set currentPage(value) {\r\n        if (value < 0)\r\n            value = 0;\r\n        if (value >= this.cellArray.length)\r\n            value = this.cellArray.length - 1;\r\n        if (value != this.currentPage_) {\r\n            this.currentPage_ = value;\r\n            Render.scheduleUpdate();\r\n            setTimeout(() => { Render.scheduleUpdate(); }, 10);\r\n        }\r\n    }\r\n    get currentPage() { return this.currentPage_; }\r\n    /**\r\n     * Determines whether connect on\r\n     */\r\n    onConnect() {\r\n        let THIS = this;\r\n        this.parentDisplayCell.getdim = function () { return THIS.dim; };\r\n        this.parentDisplayCell.setdim = function (value) { THIS.dim = value; };\r\n    }\r\n    ;\r\n    /**\r\n     * Renders pages\r\n     * @param derender\r\n     * @param node\r\n     * @param zindex\r\n     * @returns render\r\n     */\r\n    Render(derender, node, zindex) {\r\n        let newPage = this.evalFunction(this);\r\n        if (newPage != this.prevPage)\r\n            Render.update(this.cellArray[this.prevPage], true);\r\n        this.currentPage_ = this.prevPage = newPage;\r\n        //console.log(\"parentDisplayCell\", this.parentDisplayCell.label)\r\n        //this.parentDisplayCell.coord.log()\r\n        this.cellArray[this.currentPage].coord.copy(this.parentDisplayCell.coord);\r\n        return [this.cellArray[this.currentPage]];\r\n    }\r\n    ;\r\n}\r\nPages.labelNo = 0;\r\nPages.instances = {};\r\nPages.activeInstances = {};\r\nPages.defaults = {\r\n    currentPage_: 0, prevPage: 0,\r\n    evalFunction: function (thisPages) { return thisPages.currentPage; }\r\n};\r\nPages.argMap = {\r\n    string: [\"label\"],\r\n    function: [\"evalFunction\"],\r\n    dim: [\"dim_\"],\r\n    Tree_: [\"tree\"],\r\n};\r\nRender.register(\"Pages\", Pages);\r\nfunction P(...Arguments) {\r\n    return new DisplayCell(new Pages(...Arguments));\r\n}\r\n/**\r\n * Tree\r\n */\r\nclass Tree_ extends Component {\r\n    /**\r\n     * Creates an instance of tree .\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.buildBase(...Arguments);\r\n        let THIS = this;\r\n        Tree_.makeLabel(this);\r\n        Tree_.instances[this.label] = this;\r\n        if (this.Css)\r\n            this.css = this.Css.classname;\r\n        if (!this.parentTreeNode)\r\n            this.parentTreeNode = sample();\r\n        this.newNode(this.parentTreeNode);\r\n        if (this.useSelected && this.selected == undefined) {\r\n            let getIndexerArray = function (selectedInstance) {\r\n                return node_.asArray(THIS.parentTreeNode, function (node) { return [node[\"displaycell\"]]; });\r\n            };\r\n            let onselect = function (index, displaycell) {\r\n                let node = (node_.asArray(THIS.parentTreeNode)[index]);\r\n                if (THIS.selectParents) {\r\n                    while (node.ParentNode) {\r\n                        node = node.ParentNode;\r\n                        let displaycell = node[\"displaycell\"];\r\n                        let element = (displaycell.getComponent(\"Element_\"));\r\n                        if (element)\r\n                            element.setAsSelected();\r\n                    }\r\n                }\r\n            };\r\n            let onunselect = function (index, displaycell) {\r\n                if (THIS.selectParents) {\r\n                    let node = (node_.asArray(THIS.parentTreeNode)[index]);\r\n                    while (node.ParentNode) {\r\n                        node = node.ParentNode;\r\n                        let displaycell = node[\"displaycell\"];\r\n                        let element = (displaycell.getComponent(\"Element_\"));\r\n                        if (element)\r\n                            element.setAsUnSelected();\r\n                    }\r\n                }\r\n            };\r\n            this.selected = new Selected(`${this.label}`, this.selectedStartIndex, { getIndexerArray, onselect, onunselect });\r\n        }\r\n    }\r\n    static collapsedSVG(classname = \"scrollArrows\") {\r\n        return `<svg class=\"${classname}\" width=\"100%\" height=\"100%\" version=\"1.1\" viewBox=\"-10 -10 45 45\" xmlns=\"http://www.w3.org/2000/svg\">\r\n    <path transform=\"rotate(2.382 1.0017 36.146)\" d=\"m21.167 11.793-16.891 10.81-0.91654-20.033 8.9037 4.6114z\" stroke-linecap=\"round\" stroke-width=\".84667\"/>\r\n    </svg>`;\r\n    }\r\n    static expandedSVG(classname = \"scrollArrows\") {\r\n        return `<svg class=\"${classname}\" width=\"100%\" height=\"100%\" version=\"1.1\" viewBox=\"-10 -10 45 45\" xmlns=\"http://www.w3.org/2000/svg\">\r\n    <path transform=\"rotate(92.906 12.406 12.398)\" d=\"m21.167 11.793-16.891 10.81-0.91654-20.033 8.9037 4.6114z\" stroke-linecap=\"round\" stroke-width=\".84667\"/>\r\n    </svg>`;\r\n    }\r\n    static toggleCollapse(el, node, mouseEvent) {\r\n        // console.log(node)\r\n        if (!node.collapsed)\r\n            Tree_.deRenderChildren(node);\r\n        node.collapsed = !node.collapsed;\r\n        Render.scheduleUpdate();\r\n    }\r\n    static deRenderChildren(parentNode) {\r\n        for (let index = 0; index < parentNode.children.length; index++) {\r\n            let node = parentNode.children[index];\r\n            node_.traverse(node, function (node) {\r\n                Render.update(node[\"rendercell\"], true);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Icons tree\r\n     * @param node\r\n     * @returns\r\n     */\r\n    static icon(node) {\r\n        return (node.children.length) ? ((node.collapsed) ? Tree_.collapsedSVG() : Tree_.expandedSVG()) : \"\";\r\n    }\r\n    /**\r\n     * News node\r\n     * @param node\r\n     */\r\n    newNode(node) {\r\n        let THIS = this;\r\n        let argMap = {\r\n            string: [\"label\"],\r\n            DisplayCell: [\"displaycell\"],\r\n        };\r\n        node_.traverse(node, function (node) {\r\n            node.retArgs = Arguments_.argumentsByType(node.Arguments);\r\n            Arguments_.modifyClassProperties(Arguments_.retArgsMapped({}, node, { argMap }), node);\r\n            // if (node[\"DisplayCell\"]) alert(\"told ya so!\");\r\n            if (!node[\"displaycell\"])\r\n                node[\"displaycell\"] = I(node.label + Tree_.extension, node.label);\r\n            let displaycell = (node[\"displaycell\"]);\r\n            let element = displaycell.getComponent(\"Element_\");\r\n            if (!element.css && THIS.css)\r\n                element.css = THIS.css;\r\n            if (THIS.events)\r\n                element.addEvents(THIS.events);\r\n            displaycell.coord.hideWidth = true;\r\n            let icon = I(`${node.label}_icon`, `${THIS.height}px`, Tree_.pointerCss, Tree_.icon(node), events({ onclick: function (e) { Tree_.toggleCollapse(this.parentElement, node, e); } }), (el) => Tree_.icon(node));\r\n            node[\"iconElement_\"] = icon.getComponent(\"Element_\");\r\n            node[\"rendercell\"] = h(`${THIS.label}_rendercell`, icon, displaycell);\r\n        });\r\n        this.parentTreeNode = node;\r\n    }\r\n    /**\r\n     * Pre render\r\n     * @param derender\r\n     * @param node\r\n     * @param zindex\r\n     * @returns render\r\n     */\r\n    preRender(derender, node, zindex) {\r\n        this.displayHeight = (this.topMargin + this.parentTreeNode.length() * this.height) - this.parentDisplayCell.coord.y;\r\n        return undefined;\r\n    }\r\n    ;\r\n    /**\r\n     * Renders tree\r\n     * @param derender\r\n     * @param node\r\n     * @param zindex\r\n     * @returns render\r\n     */\r\n    Render(derender, node, zindex) {\r\n        let THIS = this;\r\n        let returnDisplayCellArray = [];\r\n        let PDCoord = this.parentDisplayCell.coord;\r\n        let xWithoutIndent = PDCoord.x + this.sideMargin - this.offsetx;\r\n        let y = PDCoord.y + this.topMargin - this.offsety;\r\n        let scheduleUpdate = true;\r\n        this.displayWidth = 0;\r\n        node_.traverse(this.parentTreeNode, function (node) {\r\n            if (node != THIS.parentTreeNode) {\r\n                let rendercell = node[\"rendercell\"];\r\n                if (rendercell) {\r\n                    let x = xWithoutIndent + node.depth(-2) * THIS.indent;\r\n                    rendercell.coord.copy(PDCoord, x, y, PDCoord.x + PDCoord.width - x, THIS.height, zindex);\r\n                    returnDisplayCellArray.push(rendercell);\r\n                }\r\n                y += THIS.height;\r\n                let el = Element_.elExists(node.label + Tree_.extension);\r\n                if (el) {\r\n                    scheduleUpdate = false;\r\n                    let bound = el.getBoundingClientRect();\r\n                    if (bound.x + bound.width - PDCoord.x > THIS.displayWidth)\r\n                        THIS.displayWidth = bound.x + bound.width - PDCoord.x;\r\n                }\r\n            }\r\n        }, (node) => !node.collapsed);\r\n        if ((\"ScrollBar\" in Render.classes)) {\r\n            // vertical first\r\n            if (y > PDCoord.y + PDCoord.height) {\r\n                if (!this.scrollbarv) {\r\n                    this.scrollbarv = scrollbar(this.label + \"_ScrollBarV\", false);\r\n                    this.parentDisplayCell.addComponent(this.scrollbarv);\r\n                }\r\n                this.offsety = this.scrollbarv.update(y, PDCoord.y + PDCoord.height);\r\n            }\r\n            else {\r\n                if (this.scrollbarv) {\r\n                    this.scrollbarv.delete();\r\n                    this.parentDisplayCell.deleteComponent(\"ScrollBar\", this.label + \"_ScrollBarV\");\r\n                    this.scrollbarv = undefined;\r\n                }\r\n            }\r\n            // horizontal first\r\n            if (this.displayWidth > this.parentDisplayCell.coord.width) {\r\n                if (!this.scrollbarh) {\r\n                    this.scrollbarh = scrollbar(this.label + \"_ScrollBarH\", true);\r\n                    this.parentDisplayCell.addComponent(this.scrollbarh);\r\n                }\r\n                this.offsetx = this.scrollbarh.update(this.displayWidth, this.parentDisplayCell.coord.width);\r\n            }\r\n            else {\r\n                if (this.scrollbarh) {\r\n                    this.scrollbarh.delete();\r\n                    this.parentDisplayCell.deleteComponent(\"ScrollBar\", this.label + \"_ScrollBarH\");\r\n                    this.scrollbarh = undefined;\r\n                }\r\n            }\r\n        }\r\n        if (scheduleUpdate)\r\n            Render.scheduleUpdate();\r\n        return returnDisplayCellArray;\r\n    }\r\n    ;\r\n    delete() { }\r\n}\r\nTree_.labelNo = 0;\r\nTree_.instances = {};\r\nTree_.activeInstances = {};\r\nTree_.defaults = { collapsedIcon: Tree_.collapsedSVG(), expandedIcon: Tree_.expandedSVG(),\r\n    indent: 10, topMargin: 0, sideMargin: 0, height: 20, offsetx: 0, offsety: 0,\r\n    useSelected: true, selectedStartIndex: 0, selectParents: true, cascadeCollapse: true };\r\nTree_.argMap = {\r\n    string: [\"label\"],\r\n    node_: [\"parentTreeNode\"],\r\n    DisplayCell: [\"parentDislayCell\"],\r\n    boolean: [\"useSelected\"],\r\n};\r\nTree_.scrollArrowsSVGCss = css(`scrollArrows`, `stroke: black;`, `fill: white;`, { type: \"llm\" });\r\nTree_.extension = \"_TreeNode\";\r\nTree_.pointerCss = css(\"justpointer\", \"cursor:pointer\");\r\nRender.register(\"Tree_\", Tree_);\r\n/**\r\n * Context\r\n */\r\nclass Context extends Component {\r\n    // retArgs:objectAny;   // <- this will appear\r\n    /**\r\n     * Creates an instance of context.\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.buildBase(...Arguments);\r\n        Context.makeLabel(this);\r\n        Context.instances[this.label] = this;\r\n        if (!this.contextNode)\r\n            this.contextNode = sample();\r\n        this.build();\r\n    }\r\n    /**\r\n     * Builds context\r\n     */\r\n    build() {\r\n        let THIS = this;\r\n        let displaycells = [];\r\n        for (let index = 0; index < this.contextNode.children.length; index++) {\r\n            let childNode = this.contextNode.children[index];\r\n            let retArgs = Arguments_.argumentsByType(childNode.Arguments);\r\n            let label = (\"string\" in retArgs) ? retArgs[\"string\"][0] : undefined;\r\n            let displaycell = (\"DisplayCell\" in retArgs) ? retArgs[\"DisplayCell\"][0] : undefined;\r\n            let function_ = (\"function\" in retArgs) ? retArgs[\"function\"][0] : undefined;\r\n            if (!label && displaycell)\r\n                label = displaycell.label;\r\n            displaycell = (displaycell) ? displaycell : I(`${this.label}_${label}`, label, Context.Css);\r\n            let onclick = (THIS.onclick) ? (e) => { Context.popAll(); THIS.onclick(e, displaycell, childNode); }\r\n                : (e) => { Context.popAll(); };\r\n            if (function_) {\r\n                displaycell.addEvents({ onclick: function_ });\r\n                if (THIS.onclick && !this.newFunctionReplacesold)\r\n                    displaycell.addEvents({ onclick });\r\n            }\r\n            else {\r\n                displaycell.addEvents({ onclick });\r\n            }\r\n            if (childNode.children.length)\r\n                displaycell.addComponent(context(`${childNode.label}_context`, \"onmouseover\", false, childNode, this.onclick));\r\n            childNode[\"displaycell\"] = displaycell;\r\n            displaycells.push(displaycell);\r\n        }\r\n        this.displaygroup = new DisplayGroup(`${this.label}_ContextV`, false, ...displaycells);\r\n        this.displaycell = new DisplayCell(this.displaygroup);\r\n    }\r\n    /**\r\n     * Contexts on mouse move\r\n     * @param event\r\n     * @returns\r\n     */\r\n    static ContextOnMouseMove(event) {\r\n        let X = event.clientX, Y = event.clientY;\r\n        let length = Context.activeInstanceArray.length;\r\n        let topInstance = Context.activeInstanceArray[length - 1];\r\n        let valid = ((topInstance.parentDisplayCell.coord.isPointIn(X, Y) && (length > 1 || !topInstance.byPoint))\r\n            || topInstance.displaycell.coord.isPointIn(X, Y));\r\n        if (!valid)\r\n            topInstance.pop();\r\n        return Context.activeInstanceArray.length;\r\n    }\r\n    /**\r\n     * Pops all\r\n     * @param [keepFunction]\r\n     */\r\n    static popAll(keepFunction = false) {\r\n        while (Context.activeInstanceArray.length)\r\n            Context.activeInstanceArray[Context.activeInstanceArray.length - 1].pop(keepFunction);\r\n    }\r\n    /**\r\n     * Pops context\r\n     * @param [keepFunction]\r\n     */\r\n    pop(keepFunction = false) {\r\n        // console.log(\"pop\")\r\n        let index = Context.activeInstanceArray.indexOf(this);\r\n        if (index != -1) {\r\n            Render.update(this.displaycell, true);\r\n            this.isShown = false;\r\n            Context.activeInstanceArray.splice(index, 1);\r\n            if (Context.activeInstanceArray.length == 0 && !keepFunction)\r\n                window.onmousemove = FunctionStack.pop(window.onmousemove, \"ContextOnMouseMove\");\r\n        }\r\n    }\r\n    /**\r\n     * Launchs context\r\n     * @param [event]\r\n     */\r\n    launchContext(event = undefined) {\r\n        // console.log(\"launch\")\r\n        event.preventDefault();\r\n        let length = Context.activeInstanceArray.length;\r\n        if (length) {\r\n            if (this.contextNode.root() != Context.activeInstanceArray[0].contextNode.root())\r\n                Context.popAll(true);\r\n            else {\r\n                let lastContextInstance = Context.activeInstanceArray[length - 1];\r\n                if (this.contextNode.depth() <= lastContextInstance.contextNode.depth())\r\n                    lastContextInstance.pop();\r\n            }\r\n        }\r\n        else\r\n            window.onmousemove = FunctionStack.push(window.onmousemove, Context.ContextOnMouseMove);\r\n        Context.activeInstanceArray.push(this);\r\n        this.launchEvent = event;\r\n        this.isShown = true;\r\n        Render.scheduleUpdate();\r\n    }\r\n    /**\r\n     * Determines whether connect on\r\n     */\r\n    onConnect() {\r\n        let eventObject = {};\r\n        eventObject[this.eventType] = this.launchContext.bind(this);\r\n        this.parentDisplayCell.addEvents(eventObject);\r\n    }\r\n    ;\r\n    /**\r\n     * Sets coord\r\n     * @param [Pcoord]\r\n     * @param [event]\r\n     */\r\n    setCoord(Pcoord = this.parentDisplayCell.coord, event = this.launchEvent) {\r\n        let Dcoord = this.displaycell.coord;\r\n        let Mcoord = Handler.ScreenSizeCoord;\r\n        let x = (this.byPoint) ? this.launchEvent.clientX - Context.pointOffset : ((this.toTheRight) ? Pcoord.x + Pcoord.width : Pcoord.x);\r\n        let y = (this.byPoint) ? this.launchEvent.clientY - Context.pointOffset : ((this.toTheRight) ? Pcoord.y : Pcoord.y + Pcoord.height);\r\n        let width = this.width;\r\n        let height = this.displaygroup.children.length * this.height;\r\n        if (y + height > Mcoord.y + Mcoord.height)\r\n            height = Mcoord.y + Mcoord.height - y;\r\n        this.displaycell.coord.copy(Mcoord, x, y, width, height);\r\n    }\r\n    /**\r\n     * Renders context\r\n     * @param derender\r\n     * @param node\r\n     * @param zindex\r\n     * @returns render\r\n     */\r\n    Render(derender, node, zindex) {\r\n        if (this.isShown) {\r\n            this.setCoord();\r\n            return [this.displaycell];\r\n        }\r\n        return undefined;\r\n    }\r\n    ;\r\n}\r\nContext.Css = css(\"ContextCss\", `color:black;background:white`, `color:white;background:black:cursor:pointer`);\r\nContext.labelNo = 0;\r\nContext.instances = {};\r\nContext.activeInstances = {};\r\nContext.defaults = { width: 150, height: 20, isShown: false, byPoint: true,\r\n    eventType: \"oncontextmenu\", toTheRight: true, newFunctionReplacesold: false };\r\nContext.argMap = {\r\n    string: [\"label\", \"eventType\"],\r\n    node_: [\"contextNode\"],\r\n    number: [\"width\", \"height\"],\r\n    boolean: [\"byPoint\", \"toTheRight\"],\r\n    function: [\"onclick\"],\r\n};\r\nContext.pointOffset = 5;\r\nContext.activeInstanceArray = [];\r\nfunction context(...Arguments) { return new Context(...Arguments); }\r\nRender.register(\"Context\", Context);\r\n/**\r\n * Modal\r\n */\r\nclass Modal extends Component {\r\n    /**\r\n     * Creates an instance of modal.\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.children = [];\r\n        this.buildBase(...Arguments);\r\n        Modal.makeLabel(this);\r\n        Modal.instances[this.label] = this;\r\n        if (!this.handler)\r\n            this.handler = new Handler(`${this.label}_handler`, false, this.rootDisplayCell, new Coord());\r\n        if (!this.handler.coord)\r\n            this.handler.coord = new Coord();\r\n        if (this.handler.parentDisplayCell)\r\n            this.parentDisplayCell = this.handler.parentDisplayCell;\r\n        else\r\n            this.parentDisplayCell = new DisplayCell(this.label).addComponent(this.handler);\r\n        this.parentDisplayCell.addComponent(this);\r\n        if (this.startCoord) {\r\n            this.sizer.width = this.startCoord.width;\r\n            this.sizer.height = this.startCoord.height;\r\n        }\r\n        if (\"number\" in this.retArgs)\r\n            this.sizer = this.evalNumbers(this.retArgs[\"number\"]);\r\n    }\r\n    /**\r\n     * Determines whether down on\r\n     */\r\n    static onDown() {\r\n        let THIS = this;\r\n        window.dispatchEvent(new CustomEvent('ModalStartDrag', { detail: THIS }));\r\n        Modal.movingInstace = THIS;\r\n        Modal.x = THIS.coord.x;\r\n        Modal.y = THIS.coord.y;\r\n    }\r\n    /**\r\n     * Determines whether move on\r\n     * @param mouseEvent\r\n     * @param offset\r\n     */\r\n    static onMove(mouseEvent, offset) {\r\n        let THIS = this;\r\n        THIS.coord.x = Modal.x + offset.x;\r\n        THIS.coord.y = Modal.y + offset.y;\r\n        Render.scheduleUpdate();\r\n    }\r\n    /**\r\n     * Determines whether up on\r\n     * @param mouseEvent\r\n     * @param offset\r\n     */\r\n    static onUp(mouseEvent, offset) {\r\n        let THIS = this;\r\n        Modal.movingInstace = undefined;\r\n        Modal.x = undefined;\r\n        Modal.y = undefined;\r\n        window.dispatchEvent(new CustomEvent('ModalDropped', { detail: THIS }));\r\n    }\r\n    get coord() { return this.handler.coord; }\r\n    /**\r\n     * Evals numbers\r\n     * @param numbers\r\n     * @returns numbers\r\n     */\r\n    evalNumbers(numbers) {\r\n        let qty = numbers.length;\r\n        let sizer = {};\r\n        sizer.width = numbers[0];\r\n        if (qty > 1)\r\n            sizer.height = numbers[1];\r\n        if (qty > 2)\r\n            sizer.minWidth = numbers[2];\r\n        if (qty > 3)\r\n            sizer.minHeight = numbers[3];\r\n        if (qty > 4)\r\n            sizer.maxWidth = numbers[4];\r\n        if (qty > 5)\r\n            sizer.maxHeight = numbers[5];\r\n        return sizer;\r\n    }\r\n    /**\r\n     * Determines whether connect on\r\n     */\r\n    onConnect() {\r\n        if (this.startCoord)\r\n            this.handler.coord.copy(this.startCoord);\r\n        else {\r\n            let ssCoord = Handler.ScreenSizeCoord;\r\n            let width = (this.sizer.width) ? this.sizer.width : Math.round(ssCoord.width / 3);\r\n            let height = (this.sizer.height) ? this.sizer.height : Math.round(ssCoord.height / 3);\r\n            let x = Math.round((ssCoord.width - width) / 2);\r\n            let y = Math.round((ssCoord.height - height) / 2);\r\n            this.coord.assign(x, y, width, height, 0, 0, ssCoord.width, ssCoord.height);\r\n        }\r\n    }\r\n    ;\r\n    /**\r\n     * Pre render\r\n     * @param derender\r\n     * @param node\r\n     * @param zindex\r\n     * @returns render\r\n     */\r\n    preRender(derender, node, zindex) {\r\n        if (this.sizer.minWidth && !this.stretch)\r\n            this.stretch = new Stretch(this);\r\n        let ssCoord = Handler.ScreenSizeCoord;\r\n        if (this.coord.x2 > ssCoord.width)\r\n            this.coord.x -= (this.coord.x2 - ssCoord.width);\r\n        if (this.coord.y2 > ssCoord.height)\r\n            this.coord.y -= (this.coord.y2 - ssCoord.height);\r\n        if (this.coord.x < 0)\r\n            this.coord.x = 0;\r\n        if (this.coord.y < 0)\r\n            this.coord.y = 0;\r\n        this.coord.within.width = ssCoord.width;\r\n        this.coord.within.height = ssCoord.height;\r\n        return undefined;\r\n    }\r\n    ;\r\n    /**\r\n     * Renders modal\r\n     * @param derender\r\n     * @param node\r\n     * @param zindex\r\n     * @returns render\r\n     */\r\n    Render(derender, node, zindex) {\r\n        return this.children;\r\n    }\r\n    ;\r\n    /**\r\n     * Gets child\r\n     * @param label\r\n     * @returns\r\n     */\r\n    getChild(label) {\r\n        for (let index = 0; index < this.children.length; index++)\r\n            if (this.children[index].label == label)\r\n                return this.children[index];\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Shows modal\r\n     */\r\n    show() {\r\n        if (!Handler.activeInstances[this.handler.label]) {\r\n            Handler.activeInstances[this.handler.label] = this.handler;\r\n            Render.scheduleUpdate();\r\n        }\r\n    }\r\n    /**\r\n     * Hides modal\r\n     * @param [event]\r\n     */\r\n    hide(event = undefined) {\r\n        if (Handler.activeInstances[this.handler.label]) {\r\n            Render.update(Handler.activeInstances[this.handler.label], true);\r\n            delete Handler.activeInstances[this.handler.label];\r\n        }\r\n    }\r\n    /**\r\n     * Determines whether shown is\r\n     * @returns\r\n     */\r\n    isShown() { return (Handler.activeInstances[this.handler.label]) ? true : false; }\r\n    /**\r\n     * Drags with\r\n     * @param displaycells\r\n     */\r\n    dragWith(...displaycells) {\r\n        let THIS = this;\r\n        for (let index = 0; index < displaycells.length; index++) {\r\n            const displaycell = displaycells[index];\r\n            let element = displaycell.getComponent(\"Element_\");\r\n            // console.log(element)\r\n            element.addEvents({ ondrag: [Modal.onDown.bind(THIS), Modal.onMove.bind(THIS), Modal.onUp.bind(THIS)] });\r\n        }\r\n    }\r\n    /**\r\n     * Closes with\r\n     * @param displaycells\r\n     */\r\n    closeWith(...displaycells) {\r\n        let THIS = this;\r\n        for (let index = 0; index < displaycells.length; index++) {\r\n            displaycells[index].addEvents({ onclick: THIS.hide.bind(THIS) });\r\n        }\r\n    }\r\n}\r\nModal.labelNo = 0;\r\nModal.instances = {};\r\nModal.activeInstances = {};\r\nModal.closeCss = css(\"closeCss\", `-moz-box-sizing: border-box;\r\n                                    -webkit-box-sizing: border-box;\r\n                                    border: 1px solid black;background:white;`);\r\nModal.closeSVGCss = css(`closeIcon`, `stroke: black;background:white`, `stroke: white;background:red`);\r\nModal.closeSVG = `<svg class=\"closeIcon\" width=\"100%\" height=\"100%\" version=\"1.1\" viewBox=\"0 0 25 25\" xmlns=\"http://www.w3.org/2000/svg\">\r\n    <g stroke-linecap=\"round\" stroke-width=\"3.2\"><path d=\"m2.5 2.5 20 20\"/><path d=\"m22.5 2.5-20 20\"/></g>\r\n   </svg>`;\r\nModal.defaults = { sizer: {} };\r\nModal.argMap = {\r\n    string: [\"label\"],\r\n    DisplayCell: [\"rootDisplayCell\"],\r\n    Coord: [\"startCoord\"],\r\n    Handler: [\"handler\"],\r\n};\r\n/**\r\n * Win modal\r\n */\r\nclass winModal extends Base {\r\n    /**\r\n     * Creates an instance of win modal.\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.buildBase(...Arguments);\r\n        winModal.makeLabel(this);\r\n        winModal.instances[this.label] = this;\r\n        this.build();\r\n        this.modal = new Modal(`${this.label}`, (this.suppliedHandler) ? this.suppliedHandler : this.fullDisplayCell);\r\n        this.modal.dragWith(this.titleDisplayCell);\r\n        this.modal.closeWith(this.closeDisplayCell);\r\n        if (this.onclose)\r\n            this.closeDisplayCell.addEvents({ onclick: this.onclose });\r\n        if (\"number\" in this.retArgs)\r\n            this.modal.evalNumbers(this.retArgs[\"number\"]);\r\n        if (this[\"sizer\"]) {\r\n            this.modal.sizer = this[\"sizer\"];\r\n            delete this[\"sizer\"];\r\n        }\r\n        this.show();\r\n    }\r\n    get parentDisplayCell() { return this.modal.parentDisplayCell; }\r\n    set parentDisplayCell(value) { this.modal.parentDisplayCell = value; }\r\n    show() { this.modal.show(); }\r\n    hide() { this.modal.hide(); }\r\n    /**\r\n     * Builds win modal\r\n     */\r\n    build() {\r\n        this.titleDisplayCell = I(`${this.label}_titleCell`, this.titleText, winModal.titleCss);\r\n        this.closeDisplayCell = I(`${this.label}_closeIcon`, winModal.closeSVG, `${this.headerHeight}px`);\r\n        this.headerDisplayCell = h(`${this.label}_header`, `${this.headerHeight}px`, this.titleDisplayCell, this.closeDisplayCell);\r\n        if (!this.bodyDisplayCell)\r\n            this.bodyDisplayCell = I(`${this.label}_body`, this.innerHTML, winModal.whiteBGCss);\r\n        if (this.suppliedHandler) {\r\n            this.fullDisplayCell = v(`${this.label}_full`, this.headerDisplayCell, this.suppliedHandler.parentDisplayCell);\r\n        }\r\n        else\r\n            this.fullDisplayCell = v(`${this.label}_full`, this.headerDisplayCell, this.bodyDisplayCell);\r\n    }\r\n}\r\nwinModal.labelNo = 0;\r\nwinModal.instances = {};\r\nwinModal.activeInstances = {};\r\nwinModal.defaults = { headerHeight: 20, titleText: \"My Title\", innerHTML: \"Body\" };\r\nwinModal.argMap = {\r\n    string: [\"label\", \"titleText\", \"innerHTML\"],\r\n    DisplayCell: [\"bodyDisplayCell\"],\r\n    function: [\"onclose\"],\r\n    Handler: [\"suppliedHandler\"],\r\n};\r\nwinModal.titleCss = css(`titleCss`, `background:#00CED1;cursor:pointer;text-align: center;box-sizing: border-box;\r\n    -moz-box-sizing: border-box;-webkit-box-sizing: border-box;border: 1px solid black;`, { type: \"llm\" });\r\nwinModal.closeSVGCss = css(`closeIcon`, `stroke: black;background:white;box-sizing: border-box;\r\n    -moz-box-sizing: border-box;-webkit-box-sizing: border-box;border: 1px solid black;`, `stroke: white;background:red`, { type: \"llm\" });\r\nwinModal.closeSVG = `<svg class=\"closeIcon\" width=\"100%\" height=\"100%\" version=\"1.1\" viewBox=\"0 0 25 25\" xmlns=\"http://www.w3.org/2000/svg\">\r\n      <g stroke-linecap=\"round\" stroke-width=\"3.2\"><path d=\"m2.5 2.5 20 20\"/><path d=\"m22.5 2.5-20 20\"/></g>\r\n      </svg>`;\r\nwinModal.whiteBGCss = css(`whiteBGCss`, `background:white;box-sizing: border-box;-moz-box-sizing: border-box;\r\n                                            -webkit-box-sizing: border-box;border: 1px solid black;`);\r\n/**\r\n * Stretch\r\n */\r\nclass Stretch extends Component {\r\n    /**\r\n     * Creates an instance of stretch.\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.children = [];\r\n        this.buildBase(...Arguments);\r\n        Stretch.makeLabel(this);\r\n        Stretch.instances[this.label] = this;\r\n        this.build();\r\n        if (this.modal)\r\n            this.modal.children.push(this);\r\n        this.parentDisplayCell = this.modal.parentDisplayCell;\r\n    }\r\n    static setStart(e) {\r\n        let THIS = this;\r\n        Stretch.startDrag.copy(THIS.modal.coord);\r\n    }\r\n    static updateCoord(modal, x, y, w, h, offset) {\r\n        let sd = Stretch.startDrag, mc = modal.coord, ms = modal.sizer;\r\n        mc.x = sd.x + offset.x * x;\r\n        mc.width = sd.width + offset.x * w;\r\n        mc.y = sd.y + offset.y * y;\r\n        mc.height = sd.height + offset.y * h;\r\n        if (mc.width < ms.minWidth)\r\n            mc.width = ms.minWidth;\r\n        if (mc.width > ms.maxWidth)\r\n            mc.width = ms.maxWidth;\r\n        if (mc.height < ms.minHeight)\r\n            mc.height = ms.minHeight;\r\n        if (mc.height > ms.maxHeight)\r\n            mc.height = ms.maxHeight;\r\n        Render.scheduleUpdate();\r\n    }\r\n    ;\r\n    static ulDrag(e, offset) { Stretch.updateCoord(this[\"modal\"], 1, 1, -1, -1, offset); }\r\n    static urDrag(e, offset) { Stretch.updateCoord(this[\"modal\"], 0, 1, 1, -1, offset); }\r\n    static llDrag(e, offset) { Stretch.updateCoord(this[\"modal\"], 1, 0, -1, 1, offset); }\r\n    static lrDrag(e, offset) { Stretch.updateCoord(this[\"modal\"], 0, 0, 1, 1, offset); }\r\n    /**\r\n     * Builds stretch\r\n     */\r\n    build() {\r\n        this.upperLeft = I(`${this.label}_ul`, Stretch.CssNW, events({ ondrag: [Stretch.setStart.bind(this), Stretch.ulDrag.bind(this)] }));\r\n        this.upperRight = I(`${this.label}_ur`, Stretch.CssNE, events({ ondrag: [Stretch.setStart.bind(this), Stretch.urDrag.bind(this)] }));\r\n        this.lowerLeft = I(`${this.label}_ll`, Stretch.CssNE, events({ ondrag: [Stretch.setStart.bind(this), Stretch.llDrag.bind(this)] }));\r\n        this.lowerRight = I(`${this.label}_lr`, Stretch.CssNW, events({ ondrag: [Stretch.setStart.bind(this), Stretch.lrDrag.bind(this)] }));\r\n    }\r\n    /**\r\n     * Determines whether connect on\r\n     */\r\n    onConnect() {\r\n        console.log(\"STretch Connected\");\r\n    }\r\n    ;\r\n    /**\r\n     * Pre render\r\n     * @param derender\r\n     * @param node\r\n     * @param zindex\r\n     * @returns render\r\n     */\r\n    preRender(derender, node, zindex) {\r\n        //console.log(\"Stretch Pre-Render\");\r\n        return undefined;\r\n    }\r\n    ;\r\n    /**\r\n     * Renders stretch\r\n     * @param derender\r\n     * @param node\r\n     * @param zindex\r\n     * @returns render\r\n     */\r\n    Render(derender, node, zindex) {\r\n        if (this.parentDisplayCell) {\r\n            let z = -(zindex + Render.zindexIncrement * 10);\r\n            let PDCoord = this.parentDisplayCell.coord;\r\n            this.upperLeft.coord.copy(PDCoord, PDCoord.x, PDCoord.y, Stretch.pixelSize, Stretch.pixelSize, z);\r\n            this.upperRight.coord.copy(PDCoord, PDCoord.x2 - Stretch.pixelSize, PDCoord.y, Stretch.pixelSize, Stretch.pixelSize, z);\r\n            this.lowerLeft.coord.copy(PDCoord, PDCoord.x, PDCoord.y2 - Stretch.pixelSize, Stretch.pixelSize, Stretch.pixelSize, z);\r\n            this.lowerRight.coord.copy(PDCoord, PDCoord.x2 - Stretch.pixelSize, PDCoord.y2 - Stretch.pixelSize, Stretch.pixelSize, Stretch.pixelSize, z);\r\n            return [this.upperRight, this.upperLeft, this.lowerLeft, this.lowerRight];\r\n        }\r\n        return undefined;\r\n    }\r\n    ;\r\n}\r\nStretch.labelNo = 0;\r\nStretch.instances = {};\r\nStretch.activeInstances = {};\r\nStretch.defaults = {};\r\nStretch.argMap = {\r\n    Modal: [\"modal\"],\r\n};\r\nStretch.CssNE = css(\"CssNE\", `cursor:ne-resize`);\r\nStretch.CssNW = css(\"CssNW\", `cursor:nw-resize`);\r\nStretch.pixelSize = 10;\r\nStretch.startDrag = new Coord();\r\n/**\r\n * Drag bar\r\n */\r\nclass DragBar extends Component {\r\n    /**\r\n     * Creates an instance of drag bar.\r\n     * @param Arguments\r\n     */\r\n    constructor(...Arguments) {\r\n        super();\r\n        this.buildBase(...Arguments);\r\n        DragBar.makeLabel(this);\r\n        DragBar.instances[this.label] = this;\r\n        DragBar.instances[this.label] = this;\r\n    }\r\n    /**\r\n     * Parents display group\r\n     * @param THIS\r\n     * @returns display group\r\n     */\r\n    static parentDisplayGroup(THIS) {\r\n        let node = THIS.parentDisplayCell.node;\r\n        let prev;\r\n        do {\r\n            prev = node;\r\n            node = node.ParentNode;\r\n        } while (node != undefined && Arguments_.typeof(node.Arguments[1]) != \"DisplayGroup\");\r\n        THIS.parentDisplayGroupChild = prev.Arguments[1];\r\n        let displaygroup = node.Arguments[1];\r\n        return (node) ? [node.Arguments[1], (displaygroup.children.indexOf(THIS.parentDisplayCell) == displaygroup.children.length - 1)]\r\n            : [undefined, undefined];\r\n    }\r\n    /**\r\n     * Determines whether down on\r\n     * @param e\r\n     */\r\n    static onDown(e) {\r\n        let THIS = this;\r\n        DragBar.dragStartDim = pf.pxAsNumber(THIS.parentDisplayGroupChild.dim);\r\n    }\r\n    /**\r\n     * Determines whether move on\r\n     * @param e\r\n     * @param offset\r\n     */\r\n    static onMove(e, offset) {\r\n        let THIS = this;\r\n        let newdim = DragBar.dragStartDim + (((THIS.isHor) ? offset.x : offset.y) * ((THIS.isLast) ? -1 : 1));\r\n        if (newdim > THIS.max)\r\n            newdim = THIS.max;\r\n        if (newdim < THIS.min)\r\n            newdim = THIS.min;\r\n        THIS.parentDisplayGroupChild.dim = `${newdim}px`;\r\n        Render.scheduleUpdate();\r\n    }\r\n    /**\r\n     * Determines whether up on\r\n     * @param e\r\n     * @param offset\r\n     */\r\n    static onUp(e, offset) { DragBar.dragStartDim = undefined; }\r\n    get isHor() { return this.parentDisplayGroup.isHor; }\r\n    /**\r\n     * Renders drag bar\r\n     * @param derender\r\n     * @param node\r\n     * @param zindex\r\n     * @returns render\r\n     */\r\n    Render(derender, node, zindex) {\r\n        if (!this.parentDisplayGroup) {\r\n            [this.parentDisplayGroup, this.isLast] = DragBar.parentDisplayGroup(this);\r\n            // console.log(this.label, this.isLast)\r\n            if (this.parentDisplayGroup.margin > 2)\r\n                this.width = this.parentDisplayGroup.margin;\r\n        }\r\n        if (!this.dragbarDisplayCell)\r\n            this.dragbarDisplayCell = I(`${this.label}_Dragbar`, (this.isHor) ? DragBar.horCss : DragBar.verCss);\r\n        this.dragbarDisplayCell.addEvents({ ondrag: [DragBar.onDown.bind(this), DragBar.onMove.bind(this), DragBar.onUp.bind(this)] });\r\n        this.children = [this.dragbarDisplayCell];\r\n        let PDcoord = this.parentDisplayCell.coord;\r\n        let PDG = this.parentDisplayGroup;\r\n        let x = (this.isHor) ? ((this.isLast) ? PDcoord.x - PDG.margin\r\n            : PDcoord.x2 + PDG.margin - this.width)\r\n            : PDcoord.x;\r\n        let y = (this.isHor) ? PDcoord.y\r\n            : ((this.isLast) ? PDcoord.y - PDG.margin\r\n                : PDcoord.y2 + PDG.margin - this.width);\r\n        let width = (this.isHor) ? this.width : PDcoord.width;\r\n        let height = (this.isHor) ? PDcoord.height : this.width;\r\n        this.dragbarDisplayCell.coord.copy(PDG.parentDisplayCell.coord, x, y, width, height);\r\n        return [this.dragbarDisplayCell];\r\n    }\r\n    ;\r\n}\r\nDragBar.labelNo = 0;\r\nDragBar.instances = {};\r\nDragBar.activeInstances = {};\r\nDragBar.defaults = { width: 5 };\r\nDragBar.argMap = {\r\n    string: [\"label\"],\r\n    number: [\"min\", \"max\", \"width\"],\r\n};\r\nDragBar.horCss = css(\"db_hor\", \"background-color:black;cursor: ew-resize;\");\r\nDragBar.verCss = css(\"db_ver\", \"background-color:black;cursor: ns-resize;\");\r\nlet dragbar = function (...Arguments) { return new DragBar(...Arguments); };\r\nRender.register(\"DragBar\", DragBar);\r\n\r\n\n\n//# sourceURL=webpack://llm/./dist/liefs-layout-managerV3_FULL_MODULE.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./dist/liefs-layout-managerV3_FULL_MODULE.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	llm = __webpack_exports__;
/******/ 	
/******/ })()
;
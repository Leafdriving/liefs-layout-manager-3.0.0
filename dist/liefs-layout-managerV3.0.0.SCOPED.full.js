/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./dist/liefs-layout-managerV3.0.0.full.module.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/liefs-layout-managerV3.0.0.full.module.js":
/*!********************************************************!*\
  !*** ./dist/liefs-layout-managerV3.0.0.full.module.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\n// export {ArgsObj, ArgsFunctions, Offset}\n// import {ArgsObj} from './Interfaces';\nclass BaseF {\n    static ifObjectMergeWithDefaults(THIS, CLASS) {\n        if (\"object\" in THIS.retArgs) {\n            let returnObj = CLASS.defaults; // mergeObjects doens't overwrite this!\n            for (let key in THIS.retArgs[\"object\"])\n                returnObj = BaseF.mergeObjects(returnObj, THIS.retArgs[\"object\"][key]);\n            return returnObj;\n        }\n        return CLASS.defaults;\n    }\n    static retArgsMapped(updatedDefaults, THIS, CLASS) {\n        let returnObject = {};\n        let indexNo;\n        for (let i in updatedDefaults)\n            returnObject[i] = updatedDefaults[i];\n        for (let typeName in THIS.retArgs) {\n            if (typeName in CLASS.argMap) {\n                indexNo = 0;\n                while (indexNo < THIS.retArgs[typeName].length &&\n                    indexNo < CLASS.argMap[typeName].length) {\n                    returnObject[CLASS.argMap[typeName][indexNo]] = THIS.retArgs[typeName][indexNo];\n                    indexNo++;\n                }\n            }\n        }\n        return returnObject;\n    }\n    static argumentsByType(Args, // 1st argument is a list of args.\n    customTypes = []) {\n        customTypes = customTypes.concat(Base.defaultIsChecks); // assumed these are included.\n        let returnArray = {};\n        let valueType;\n        let returnValue;\n        for (let value of Args) {\n            valueType = typeof (value); // evaluate type\n            for (let checkFunction of customTypes) { // check if it is a custom Type\n                returnValue = checkFunction(value);\n                if (returnValue)\n                    valueType = returnValue;\n            }\n            if (!(valueType in returnArray))\n                returnArray[valueType] = []; // If type doesn't exist, add empty array\n            returnArray[valueType].push(value); // Assign Type Value\n        }\n        return returnArray;\n    }\n    static modifyClassProperties(argobj, targetobject) {\n        for (let key of Object.keys(argobj))\n            targetobject[key] = argobj[key];\n    }\n}\nBaseF.mergeObjects = function (startObj, AddObj) {\n    let returnObject = {};\n    for (let i in startObj)\n        returnObject[i] = startObj[i];\n    for (let j in AddObj)\n        returnObject[j] = AddObj[j];\n    return returnObject;\n};\nclass Base {\n    constructor() {\n    }\n    // static instances:any[] = [];\n    // static activeInstances:any[] = [];\n    static byLabel(label) {\n        let CLASS = this;\n        for (let key in CLASS[\"instances\"])\n            if (CLASS[\"instances\"][key].label == label)\n                return CLASS[\"instances\"][key];\n        return undefined;\n    }\n    static pop(instance = undefined) {\n        let CLASS = this;\n        instance = CLASS.stringOrObject(instance);\n        if (instance == undefined)\n            instance = CLASS[\"instances\"][CLASS[\"instances\"].length - 1];\n        CLASS.deactivate(instance);\n        let index = CLASS[\"instances\"].indexOf(instance);\n        if (index != -1)\n            CLASS[\"instances\"].splice(index, 1);\n    }\n    static push(instance, toActive = false) {\n        let CLASS = this;\n        instance = CLASS.stringOrObject(instance);\n        CLASS.pop(instance); // if pushing same, remove previous\n        CLASS[\"instances\"].push(instance);\n        if (toActive)\n            CLASS.activate(instance);\n    }\n    static deactivate(instance) {\n        let CLASS = this;\n        instance = CLASS.stringOrObject(instance);\n        let index = CLASS[\"activeInstances\"].indexOf(instance);\n        if (index != -1)\n            CLASS[\"activeInstances\"].splice(index, 1);\n    }\n    static activate(instance) {\n        let CLASS = this;\n        instance = CLASS.stringOrObject(instance);\n        CLASS.deactivate(instance);\n        CLASS[\"activeInstances\"].push(instance);\n    }\n    static stringOrObject(instance) {\n        if (typeof (instance) == \"string\")\n            instance = this.byLabel(instance);\n        return instance;\n    }\n    buildBase(...Arguments) { this.constructor[\"buildBase\"](this, ...Arguments); }\n    static buildBase(THIS, ...Arguments) {\n        let CLASS = this;\n        if (CLASS[\"labelNo\"] == undefined)\n            CLASS[\"labelNo\"] = 0;\n        if (CLASS[\"defaults\"] == undefined)\n            CLASS[\"defaults\"] = {};\n        if (CLASS[\"argMap\"] == undefined)\n            CLASS[\"argMap\"] = {};\n        if (CLASS[\"instances\"] == undefined)\n            CLASS[\"instances\"] = [];\n        if (CLASS[\"activeInstances\"] == undefined)\n            CLASS[\"activeInstances\"] = [];\n        CLASS.push(THIS);\n        THIS.retArgs = BaseF.argumentsByType(Arguments);\n        let updatedDefaults = BaseF.ifObjectMergeWithDefaults(THIS, CLASS);\n        let retArgsMapped = BaseF.retArgsMapped(updatedDefaults, THIS, CLASS);\n        BaseF.modifyClassProperties(retArgsMapped, THIS);\n    }\n    static makeLabel(instance) {\n        let CLASS = this;\n        if (instance[\"label\"] == undefined || instance[\"label\"].trim() == \"\") {\n            CLASS[\"labelNo\"] += 1;\n            instance[\"label\"] = `${CLASS[\"name\"]}_${CLASS[\"labelNo\"]}`;\n        }\n    }\n}\n// export {BaseF, Base};\n// class Test extends Base {\n//     static labelNo = 0;\n//     static instances:Test[] = [];\n//     static activeInstances:Test[] = [];\n//     static defaults = {\n//         tag: \"DIV\",\n//     }\n//     static argMap = {\n//         string : [\"label\", \"innerHTML\", \"css\"],\n//         number : [\"marginLeft\", \"marginTop\", \"marginRight\", \"marginBottom\"],\n//     }\n//     // retArgs:ArgsObj;   // <- this will appear\n//     constructor(...Arguments:any){\n//         super();this.buildBase(...Arguments);\n//         Test.makeLabel(this);\n//     }\n// }\nclass FunctionStack {\n    static push(label, function_) {\n        if (!(label in FunctionStack.instanceObj))\n            FunctionStack.instanceObj[label] = [];\n        FunctionStack.instanceObj[label].push(function_);\n    }\n    static function(label) {\n        return function (...Arguments) {\n            let list = FunctionStack.instanceObj[label];\n            if (list)\n                for (let index = 0; index < list.length; index++)\n                    list[index](...Arguments);\n        };\n    }\n    static pop(label) { FunctionStack.instanceObj[label] = []; }\n}\nFunctionStack.instanceObj = {};\n// export {FunctionStack}\n// import {Base} from './Base';\n// import {ArgsObj} from './Interfaces';\nclass mf {\n    /**\n    * Sample Comment\n    * argobj is blah blah\n    * @returns blah blah\n    */\n    static modifyClassProperties(argobj, targetobject) {\n        for (let key of Object.keys(argobj)) {\n            if (typeof (argobj[key]) == \"function\" && key == \"label\") {\n                targetobject[key] = argobj[key]();\n            }\n            else\n                targetobject[key] = argobj[key];\n        }\n    }\n    static applyArguments(callLabel, Arguments, classDefaults, classArgmap, THIS, customtypes = []) {\n        let retArgs = pf.sortArgs(Arguments, callLabel, customtypes);\n        let updatedDefaults = pf.ifObjectMergeWithDefaults(retArgs, classDefaults);\n        let retArgsMapped = pf.retArgsMapped(retArgs, updatedDefaults, classArgmap);\n        mf.modifyClassProperties(retArgsMapped, THIS);\n    }\n}\nclass pf {\n    /**\n    * 'message' is the string outputed to the viewer\n    * @returns nothing\n    */\n    static errorHandling(message) {\n        console.log(`Error Handeling Called\\n${message}`);\n    }\n    static commonKeys(obj1, obj2) {\n        let returnStringArray = [];\n        for (let index in obj1)\n            if (index in obj2)\n                returnStringArray.push(index);\n        return returnStringArray;\n    }\n    static retArgsMapped(retArgs, defaults, argsMap) {\n        let returnObject = {};\n        let propertyName;\n        let indexNo;\n        for (let i in defaults)\n            returnObject[i] = defaults[i];\n        for (let typeName in retArgs) {\n            if (typeName in argsMap) {\n                indexNo = 0;\n                while (indexNo < retArgs[typeName].length &&\n                    indexNo < argsMap[typeName].length) {\n                    returnObject[argsMap[typeName][indexNo]] = retArgs[typeName][indexNo];\n                    indexNo++;\n                }\n            }\n        }\n        return returnObject;\n    }\n    static ifObjectMergeWithDefaults(retArgs, defaults) {\n        if (\"object\" in retArgs) {\n            let returnObj = defaults;\n            for (let key in retArgs[\"object\"]) {\n                returnObj = pf.mergeObjects(returnObj, retArgs[\"object\"][key]);\n            }\n            return returnObj;\n        }\n        return defaults;\n        // return (\"object\" in retArgs) ? pf.mergeObjects(defaults, retArgs[\"object\"][0]) : defaults;\n    }\n    static sortArgs(Args, // 1st argument is a list of args.\n    label = \"unlabeled\", // 2nd argument is a debug label\n    customTypes = []) {\n        customTypes = customTypes.concat(pf.defaultIsChecks); // assumed these are included.\n        let returnArray = {};\n        let valueType;\n        let returnValue;\n        for (let value of Args) {\n            valueType = typeof (value); // evaluate type\n            for (let checkFunction of customTypes) { // check if it is a custom Type\n                returnValue = checkFunction(value);\n                if (returnValue) {\n                    valueType = returnValue;\n                }\n            }\n            if (!(valueType in returnArray)) { // If type doesn't exist, add empty array\n                returnArray[valueType] = [];\n            }\n            returnArray[valueType].push(value); // Assign Type Value\n        }\n        ;\n        return returnArray;\n    }\n    static setAttrib(el, attrib, value) {\n        let prevAttrib = el.getAttribute(attrib);\n        if (prevAttrib != value) {\n            let att = document.createAttribute(attrib);\n            att.value = value;\n            el.setAttributeNode(att);\n        }\n    }\n    static getAttribs(el, retObj = {}) {\n        for (let i = 0; i < el.attributes.length; i++) {\n            retObj[el.attributes[i].name] = el.attributes[i].value;\n        }\n        return retObj;\n    }\n    static elExists(id_label) { return document.getElementById(id_label); }\n    static viewport() {\n        var width = window.innerWidth || document.documentElement.clientWidth ||\n            document.body.clientWidth;\n        var height = window.innerHeight || document.documentElement.clientHeight ||\n            document.body.clientHeight;\n        return [width, height];\n    }\n    static errorReporting(errString) {\n        console.log(\"Error Reporting\");\n        console.log(errString);\n    }\n    static uis0(num) { return (num == undefined) ? 0 : num; }\n    // static concatArray(main:DisplayCell[], added:DisplayCell[]){for (let displaycell of added) main.push(displaycell)}\n    static parseURLParams(url = window.location.href) {\n        let queryStart = url.indexOf(\"?\") + 1, queryEnd = url.indexOf(\"#\") + 1 || url.length + 1, query = url.slice(queryStart, queryEnd - 1), pairs = query.replace(/\\+/g, \" \").split(\"&\"), parms = {}, i, n, v, nv;\n        if (query === url || query === \"\")\n            return;\n        for (i = 0; i < pairs.length; i++) {\n            nv = pairs[i].split(\"=\", 2);\n            n = decodeURIComponent(nv[0]);\n            v = decodeURIComponent(nv[1]);\n            if (!parms.hasOwnProperty(n))\n                parms[n] = [];\n            parms[n].push(nv.length === 2 ? v : null);\n        }\n        return parms;\n    }\n}\npf.isTypePx = function (it) { if (typeof (it) == \"string\" && it.substr(-2) == \"px\")\n    return true; return false; };\npf.pxAsNumber = function (dim) { return +(dim.slice(0, -2)); };\npf.isTypePercent = function (it) { if (typeof (it) == \"string\" && it.substr(-1) == \"%\")\n    return true; return false; };\npf.percentAsNumber = function (dim) { return +(dim.slice(0, -1)); };\npf.isDim = function (it) { if ((typeof (it) == \"string\") && (it.substr(-2) == \"px\" || it.substr(-1) == \"%\"))\n    return \"dim\"; };\npf.isArray = function (it) { if (typeof (it) == \"object\" && Array.isArray(it))\n    return \"Array\"; };\npf.isObjectAClass = function (it) { if (typeof (it) == \"object\" && it.constructor.name != \"Object\")\n    return it.constructor.name; };\npf.defaultIsChecks = [pf.isArray, pf.isObjectAClass, pf.isDim];\npf.classProperties = function (a) { return Object.getOwnPropertyNames(a); };\npf.pad_with_zeroes = function (Number, length = 3) {\n    let returnString = '' + Number;\n    while (returnString.length < length)\n        returnString = '0' + returnString;\n    return returnString;\n};\npf.mergeObjects = function (startObj, AddObj) {\n    let returnObject = {};\n    for (let i in startObj)\n        returnObject[i] = startObj[i];\n    for (let j in AddObj)\n        returnObject[j] = AddObj[j];\n    return returnObject;\n};\nBase.defaultIsChecks = [pf.isArray, pf.isObjectAClass, pf.isDim];\n// export {mf, pf}\n// import {BaseF, Base} from './Base';\n// import {ArgsObj, ArgsFunctions, Offset} from './Interfaces';\n// import {Handler} from './Handler';\n// import {mf, pf} from './PureFunctions';\nvar _x_, _y_, _width_, _height_;\nclass Point {\n}\nclass Within {\n    constructor(...Arguments) {\n        mf.applyArguments(\"Within\", Arguments, {}, { number: [\"x\", \"y\", \"width\", \"height\"] }, this);\n    }\n    clipStyleString(sub) {\n        return Coord.clipStyleString(this, sub);\n    }\n    reset() { this.x = this.y = this.width = this.height = undefined; }\n    ;\n}\nclass Coord extends Base {\n    constructor(...Arguments) {\n        super();\n        _x_.set(this, void 0);\n        _y_.set(this, void 0);\n        _width_.set(this, void 0);\n        _height_.set(this, void 0);\n        this.within = new Within();\n        this.buildBase(...Arguments);\n        Coord.makeLabel(this);\n    }\n    get x() { return __classPrivateFieldGet(this, _x_) + ((this.offset) ? this.offset.x : 0); }\n    set x(x) { __classPrivateFieldSet(this, _x_, x); }\n    get y() { return __classPrivateFieldGet(this, _y_) + ((this.offset) ? this.offset.y : 0); }\n    set y(y) { __classPrivateFieldSet(this, _y_, y); }\n    get width() { return __classPrivateFieldGet(this, _width_) + ((this.offset) ? this.offset.width : 0); }\n    set width(width) { __classPrivateFieldSet(this, _width_, width); }\n    get height() { return __classPrivateFieldGet(this, _height_) + ((this.offset) ? this.offset.height : 0); }\n    set height(height) { __classPrivateFieldSet(this, _height_, height); }\n    setOffset(x = 0, y = 0, width = 0, height = 0) {\n        if (x == 0 && y == 0 && width == 0 && height == 0)\n            this.offset = undefined;\n        else\n            this.offset = { x, y, width, height };\n    }\n    cropWithin(within = this.within) {\n        let x = this.x, y = this.y, width = this.width, height = this.height, x2 = x + width, y2 = y + height;\n        let wx = within.x, wy = within.y, wwidth = within.width, wheight = within.height, wx2 = wx + wwidth, wy2 = wy + wheight;\n        let bx = (x > wx) ? x : wx;\n        let sx2 = (x2 < wx2) ? x2 : wx2;\n        let by = (y > wy) ? y : wy;\n        let sy2 = (y2 < wy2) ? y2 : wy2;\n        this.within.x = bx;\n        this.within.width = sx2 - bx;\n        this.within.y = by;\n        this.within.height = sy2 - by;\n    }\n    // copyWithin(...Arguments:any){\n    //     let possArgs:{x?:number,y?:number,width?:number,height?:number, isRoot?:boolean, Coord?:Coord} = {};\n    //     mf.applyArguments(\"Coord.copyWithin\", Arguments, {isRoot: false}, Coord.CopyArgMap, possArgs);\n    //     let isRoot = possArgs.isRoot;\n    //     if (possArgs.isRoot) {\n    //         for (let key of [\"x\", \"y\", \"width\", \"height\"]) {\n    //             this.within[key] = this[key];\n    //         }\n    //     } else {\n    //         if (\"Coord\" in possArgs) {\n    //             let coord = possArgs.Coord\n    //             for (let key of [\"x\", \"y\", \"width\", \"height\"]) {\n    //                 this.within[key] = coord.within[key];\n    //             }\n    //             let x=this.x, y=this.y, width=this.width, height=this.height, x2=x+width, y2=y+height;\n    //             let wx=this.within.x, wy=this.within.y, wwidth=this.within.width, wheight=this.within.height, wx2=wx+wwidth, wy2=wy+wheight;\n    //             let bx = (x > wx) ? x : wx;\n    //             let sx2 = (x2 < wx2) ? x2 : wx2;\n    //             let by = (y > wy) ? y : wy;\n    //             let sy2 = (y2 < wy2) ? y2 : wy2;\n    //             this.within.x = bx;\n    //             this.within.width = sx2-bx;\n    //             this.within.y = by;\n    //             this.within.height = sy2-by;\n    //         } else {\n    //             console.log(\"Boo\");\n    //         }\n    //     }\n    // }\n    applyMargins(left, top, right, bottom) {\n        this.x += left;\n        this.within.x += left;\n        this.y += top;\n        this.within.y += top;\n        this.width -= (left + right);\n        this.within.width -= (left + right);\n        this.height -= (top + bottom);\n        this.within.height -= (top + bottom);\n    }\n    assign(x = undefined, y = undefined, width = undefined, height = undefined, wx = undefined, wy = undefined, wwidth = undefined, wheight = undefined, zindex = undefined) {\n        if (x != undefined)\n            this.x = x;\n        if (y != undefined)\n            this.y = y;\n        if (width != undefined)\n            this.width = width;\n        if (height != undefined)\n            this.height = height;\n        if (wx != undefined)\n            this.within.x = wx;\n        if (wy != undefined)\n            this.within.y = wy;\n        if (wwidth != undefined)\n            this.within.width = wwidth;\n        if (wheight != undefined)\n            this.within.height = wheight;\n        if (zindex != undefined)\n            this.zindex = zindex;\n    }\n    copy(fromCoord) {\n        this.x = fromCoord.x;\n        this.y = fromCoord.y;\n        this.width = fromCoord.width;\n        this.height = fromCoord.height;\n        this.zindex = fromCoord.zindex;\n        this.within.x = fromCoord.within.x;\n        this.within.y = fromCoord.within.y;\n        this.within.width = fromCoord.within.width;\n        this.within.height = fromCoord.within.height;\n    }\n    // // if no object, x, width, y, height, zindex\n    // // if object left, top, right, bottom, zindex\n    // let possArgs:{x?:number,y?:number,width?:number,height?:number,zindex?:number,\n    //        left?:number,right?:number,top?:number,bottom?:number,\n    //        Within?:Within,Coord?:Coord} = {};\n    // let obj:Coord;\n    // mf.applyArguments(\"Coord.copy\", Arguments, {}, Coord.CopyArgMap, possArgs);\n    // /*if (\"Within\" in possArgs) obj = possArgs.Within;\n    // else*/ if (\"Coord\" in possArgs) {\n    //     obj = possArgs.Coord;\n    //     this.within = possArgs.Coord.within;\n    // }\n    // if (obj) {possArgs.left = (possArgs.x) ? possArgs.x : 0; possArgs.top = (possArgs.y) ? possArgs.y : 0;\n    //           possArgs.right = (possArgs.width) ? possArgs.width : 0;possArgs.bottom= (possArgs.height) ? possArgs.height : 0\n    // }\n    // this.x = (obj) ? obj.x + possArgs.left : ((\"x\" in possArgs) ? possArgs.x : this.x);\n    // this.y = (obj) ? obj.y + possArgs.top  : ((\"y\" in possArgs) ? possArgs.y : this.y);\n    // this.width = (obj) ? obj.width - (possArgs.left + possArgs.right)\n    //                    : ( (possArgs.width) ? possArgs.width : this.width );\n    // this.height = (obj) ? obj.height - (possArgs.top + possArgs.bottom)\n    //                    : ( (possArgs.height) ? possArgs.height : this.height );\n    // this.zindex = (\"zindex\" in possArgs) ? possArgs.zindex : Handler.currentZindex;\n    // replace(x:number, y:number, width:number, height:number, zindex:number = undefined) {\n    //     if (x != undefined) this.x = x;\n    //     if (y != undefined)this.y = y;\n    //     if (width != undefined) this.width = width;\n    //     if (height != undefined) this.height = height;\n    //     if (zindex != undefined) this.zindex = zindex;\n    // }\n    isCoordCompletelyOutside(WITHIN = this.within) {\n        return ((WITHIN.x + WITHIN.width < this.x) ||\n            (WITHIN.x > this.x + this.width) ||\n            (WITHIN.y + WITHIN.height < this.y) ||\n            (WITHIN.y > this.y + this.height));\n    }\n    derender(derender) { return derender || this.isCoordCompletelyOutside(); }\n    clipStyleString(COORD) {\n        return Coord.clipStyleString(this, COORD);\n    }\n    newClipStyleString(WITHIN = this.within) {\n        return Coord.clipStyleString(WITHIN, this);\n    }\n    static clipStyleString(WITHIN, COORD) {\n        let returnString = \"\";\n        let left = (COORD.x < WITHIN.x) ? (WITHIN.x - COORD.x) : 0;\n        let right;\n        if (COORD.hideWidth) {\n            let el = document.getElementById(COORD.label);\n            let bound = el.getBoundingClientRect();\n            right = (COORD.x + bound.width > WITHIN.x + WITHIN.width) ? (COORD.x + bound.width - (WITHIN.x + WITHIN.width)) : 0;\n        }\n        else\n            right = (COORD.x + COORD.width > WITHIN.x + WITHIN.width) ? (COORD.x + COORD.width - (WITHIN.x + WITHIN.width)) : 0;\n        let top = (COORD.y < WITHIN.y) ? (WITHIN.y - COORD.y) : 0;\n        let bottom = (COORD.y + COORD.height > WITHIN.y + WITHIN.height) ? (COORD.y + COORD.height - (WITHIN.y + WITHIN.height)) : 0;\n        if (left + right + top + bottom > 0)\n            returnString = `clip-path: inset(${top}px ${right}px ${bottom}px ${left}px);`;\n        return returnString;\n    }\n    isPointIn(x, y) { return (this.x <= x && x <= this.x + this.width && this.y <= y && y <= this.y + this.height); }\n    asAttributeString() {\n        return `left: ${this.x}px; top:${this.y}px; width:${this.width}px; height:${this.height}px; ` +\n            `z-index:${this.zindex};`;\n    }\n    newAsAttributeString() {\n        return `left: ${this.x}px; top:${this.y}px;`\n            + `${(this.hideWidth) ? \"\" : \"width:\" + this.width + \"px; \"}`\n            + `height:${this.height}px; z-index:${this.zindex + ((Handler.activeOffset) ? Handler.zindexIncrement * 3 : 0)};${this.newClipStyleString()}`;\n    }\n}\n_x_ = new WeakMap(), _y_ = new WeakMap(), _width_ = new WeakMap(), _height_ = new WeakMap();\nCoord.instances = [];\nCoord.activeInstances = [];\nCoord.defaults = {\n    x: 0, y: 0, width: 0, height: 0, zindex: 0\n};\nCoord.argMap = {\n    string: [\"label\"],\n    number: [\"x\", \"y\", \"width\", \"height\", \"zindex\"],\n    boolean: [\"hideWidth\"]\n};\nCoord.CopyArgMap = { Within: [\"Within\"], Coord: [\"Coord\"], boolean: [\"isRoot\"],\n    number: [\"x\", \"y\", \"width\", \"height\", \"zindex\"] };\n// export {Point, Within, Coord}\n// import {ArgsObj, ArgsFunctions} from './Interfaces'\n// import {BaseF, Base} from './Base';\n// import {events, Events} from './Events';\n// import {Css, css} from './Css';\n// import {mf, pf} from './PureFunctions';\n/**\n * This Class Holds the HTMLElement\n */\nclass HtmlBlock extends Base {\n    constructor(...Arguments) {\n        super();\n        this.attributes = {};\n        this.buildBase(...Arguments);\n        let elementWithIdAsLabel = document.getElementById(this.label);\n        if (elementWithIdAsLabel) {\n            this.innerHTML = elementWithIdAsLabel.innerHTML;\n            this.attributes = pf.getAttribs(elementWithIdAsLabel, this.attributes);\n            elementWithIdAsLabel.remove();\n        }\n        if (\"Css\" in this.retArgs)\n            for (let css of this.retArgs[\"Css\"])\n                this.css = (this.css + \" \" + css.classname).trim();\n        if (\"string\" in this.retArgs && this.retArgs.string.length > 3)\n            this.css += \" \" + this.retArgs.string.splice(3).join(' ');\n        if (\"number\" in this.retArgs) {\n            let length = this.retArgs[\"number\"].length;\n            if (length == 1) {\n                this.marginRight = this.marginTop = this.marginBottom = this.marginLeft;\n            }\n            else if (length == 2) {\n                this.marginRight = this.marginLeft;\n                this.marginBottom = this.marginTop;\n            }\n        }\n        HtmlBlock.makeLabel(this);\n    }\n}\nHtmlBlock.instances = [];\nHtmlBlock.activeInstances = [];\nHtmlBlock.defaults = {\n    innerHTML: \" \",\n    tag: \"DIV\",\n    css: \"\",\n    dim: \"\"\n};\nHtmlBlock.argMap = {\n    string: [\"label\", \"innerHTML\", \"css\"],\n    dim: [\"dim\"],\n    Events: [\"events\"],\n    number: [\"marginLeft\", \"marginTop\", \"marginRight\", \"marginBottom\"],\n    // Tree: [\"tree\"],\n    boolean: [\"hideWidth\"],\n};\nfunction html(...Arguments) {\n    let htmlblock = new HtmlBlock(\"\", ...Arguments);\n    htmlblock.label = HtmlBlock.defaults[\"label\"]();\n    return htmlblock;\n}\n// export {html, HtmlBlock}\n// import {ArgsObj} from './Interfaces';\n// import {Base, BaseF} from './Base';\n// import {HtmlBlock} from './htmlBlock';\n// import {Drag} from './Drag';\n// import {Hold} from './Hold';\nclass Events extends Base {\n    constructor(...Arguments) {\n        super();\n        let retArgs = BaseF.argumentsByType(Arguments);\n        if (\"object\" in retArgs) {\n            this.actions = retArgs[\"object\"][0];\n            delete retArgs[\"object\"];\n        }\n        this.buildBase(...Arguments);\n        Events.makeLabel(this);\n    }\n    applyToHtmlBlock(htmlblock) {\n        let el = htmlblock.el;\n        this.label = htmlblock.label;\n        for (let key in this.actions) {\n            if (key == \"onhold\") {\n                new Hold(el, this.actions[key]);\n            }\n            else if (key == \"ondrag\") {\n                new Drag(el, this.actions[key]);\n            }\n            else {\n                let value_Function = this.actions[key];\n                Events.history.push(`document.getElementById(\"${htmlblock.label}\").${key} = ${value_Function}`);\n                el[key] = value_Function;\n            }\n        }\n    }\n    static do(event) {\n        console.log(event);\n        console.log(this);\n    }\n}\nEvents.elementId = \"llmEvents\";\nEvents.instances = [];\nEvents.activeInstances = [];\nEvents.history = [];\nEvents.defaults = {};\nEvents.argMap = {\n    string: [\"label\"]\n};\nfunction events(...Arguments) { return new Events(...Arguments); }\n// export {events, Events}\n// import {Base} from './Base';\n// import {Coord} from './Coord';\n// import {HtmlBlock} from './htmlBlock';\n// import {DisplayGroup} from './DisplayGroup';\n// import {events, Events} from './Events';\n// import {Overlay} from './Overlay';\n// import {Pages} from './Pages';\n// import {vMenuBar, hMenuBar, context, Context} from './Context';\nvar _htmlBlock_, _displaygroup_;\nclass DisplayCell extends Base {\n    constructor(...Arguments) {\n        super();\n        _htmlBlock_.set(this, undefined);\n        _displaygroup_.set(this, undefined);\n        this.overlays = [];\n        this.isRendered = false;\n        this.buildBase(...Arguments);\n        if (this.displaygroup && this.displaygroup.htmlBlock) {\n            this.htmlBlock = this.displaygroup.htmlBlock;\n        }\n        if (this.htmlBlock)\n            this.label = `${this.htmlBlock.label}`;\n        if (!this.label)\n            this.label = (this.htmlBlock) ? this.htmlBlock.label + \"_DisplayCell\"\n                : (this.displaygroup) ? this.displaygroup.label + \"_DisplayCell\"\n                    : (this.pages) ? this.pages.label + \"_DisplayCell\" : undefined;\n        if (this.htmlBlock && this.htmlBlock.hideWidth)\n            this.coord = new Coord(this.label, true);\n        else\n            this.coord = new Coord(this.label);\n        DisplayCell.makeLabel(this);\n    }\n    get htmlBlock() { return __classPrivateFieldGet(this, _htmlBlock_); }\n    set htmlBlock(htmlblock) {\n        __classPrivateFieldSet(this, _htmlBlock_, htmlblock);\n        if (__classPrivateFieldGet(this, _htmlBlock_).dim)\n            this.dim = __classPrivateFieldGet(this, _htmlBlock_).dim;\n        if (__classPrivateFieldGet(this, _htmlBlock_).minDisplayGroupSize)\n            this.minDisplayGroupSize = __classPrivateFieldGet(this, _htmlBlock_).minDisplayGroupSize;\n    }\n    get displaygroup() { return __classPrivateFieldGet(this, _displaygroup_); }\n    set displaygroup(displaygroup) {\n        __classPrivateFieldSet(this, _displaygroup_, displaygroup);\n        if (__classPrivateFieldGet(this, _displaygroup_).dim)\n            this.dim = __classPrivateFieldGet(this, _displaygroup_).dim;\n    }\n    get minDisplayGroupSize() { return (this.minDisplayGroupSize_) ? this.minDisplayGroupSize_ : DisplayCell.minDisplayGroupSize; }\n    set minDisplayGroupSize(size) { this.minDisplayGroupSize = size; }\n    addOverlay(overlay) { this.overlays.push(overlay); }\n    hMenuBar(menuObj) {\n        menuObj[\"launchcell\"] = this;\n        this.htmlBlock.events = events({ onmouseover: hMenuBar(menuObj) }); //////////////// COME BACK HERE!!!!\n    }\n    vMenuBar(menuObj) {\n        menuObj[\"launchcell\"] = this;\n        this.htmlBlock.events = events({ onmouseover: vMenuBar(menuObj) }); //////////////// COME BACK HERE!!!!\n    }\n    static concatArray(main, added) { for (let displaycell of added)\n        main.push(displaycell); }\n}\n_htmlBlock_ = new WeakMap(), _displaygroup_ = new WeakMap();\nDisplayCell.instances = [];\nDisplayCell.activeInstances = [];\nDisplayCell.minDisplayGroupSize = 200; // copied from htmlblock\nDisplayCell.defaults = {\n    dim: \"\"\n};\nDisplayCell.argMap = {\n    string: [\"label\"],\n    HtmlBlock: [\"htmlBlock\"],\n    DisplayGroup: [\"displaygroup\"],\n    dim: [\"dim\"],\n    Pages: [\"pages\"],\n    function: [\"preRenderCallback\", \"postRenderCallback\"],\n};\nfunction I(...Arguments) {\n    return new DisplayCell(new HtmlBlock(...Arguments));\n    // let newblock = new HtmlBlock(...Arguments);\n    // return (newblock.dim) ? new DisplayCell(newblock, newblock.dim) : new DisplayCell(newblock);\n}\n// export {I, DisplayCell}\n// import {Base} from './Base';\n// import {DisplayCell} from './DisplayCell';\n// import {Coord} from './Coord';\n// import {HtmlBlock} from './htmlBlock';\n// import {Overlay} from './Overlay';\n// import {mf, pf} from './PureFunctions';\nclass DisplayGroup extends Base {\n    // minimumCellSize:number;\n    // renderStartIndex:number;\n    // renderEndIndex:number;\n    constructor(...Arguments) {\n        super();\n        this.cellArray = [];\n        this.htmlBlock = undefined;\n        this.overlay = undefined;\n        this.buildBase(...Arguments);\n        if (\"DisplayCell\" in this.retArgs)\n            this.cellArray = this.retArgs[\"DisplayCell\"];\n        if (\"HtmlBlock\" in this.retArgs) {\n            this.htmlBlock = this.retArgs[\"HtmlBlock\"][0];\n        }\n        if (\"Array\" in this.retArgs)\n            this.cellArray = this.retArgs[\"Array\"][0];\n        if ((\"number\" in this.retArgs) && this.retArgs[\"number\"].length == 1)\n            this.marginVer = this.marginHor = this.retArgs[\"number\"][0];\n        this.coord = new Coord(this.label);\n        // Fill In Dim Values\n        let percentsum = 0;\n        let numOfEmptydims = 0;\n        for (let displaycell of this.cellArray) {\n            let dim = displaycell.dim;\n            if (dim == \"\")\n                numOfEmptydims++;\n            else if (pf.isTypePercent(dim))\n                percentsum += pf.percentAsNumber(dim);\n        }\n        let percentRamaining = 100 - percentsum;\n        if (numOfEmptydims) {\n            let newDimValue = String(percentRamaining / numOfEmptydims) + \"%\";\n            for (let displaycell of this.cellArray)\n                if (displaycell.dim == \"\")\n                    displaycell.dim = newDimValue;\n        }\n        DisplayGroup.makeLabel(this);\n    }\n    percentToPx(displaycell /* child in cellarray */) {\n        let percentAsNumber = pf.percentAsNumber(displaycell.dim);\n        let percentLeft = 100 - percentAsNumber;\n        displaycell.dim = `${(this.ishor) ? displaycell.coord.width : displaycell.coord.height}px`;\n        // loop cellarray to add percent where you can\n        for (let index = 0; index < this.cellArray.length; index++) {\n            let cellOfArray = this.cellArray[index];\n            if (pf.isTypePercent(cellOfArray.dim)) {\n                let thisPercent = pf.percentAsNumber(cellOfArray.dim);\n                thisPercent += (thisPercent / percentLeft) * percentAsNumber;\n                cellOfArray.dim = `${thisPercent}%`;\n            }\n        }\n    }\n    totalPx(addMin = false) {\n        let cellArray = this.cellArray;\n        let totalFixedpx = 0;\n        for (let displaycell of cellArray) {\n            if (displaycell.pages && (!displaycell.dim)) {\n                displaycell.dim = displaycell.pages.evalCell().dim; // only covers one loop!\n            }\n            if (pf.isTypePx(displaycell.dim))\n                totalFixedpx += pf.pxAsNumber(displaycell.dim);\n            else if (addMin)\n                totalFixedpx += displaycell.minDisplayGroupSize;\n        }\n        return totalFixedpx;\n    }\n}\nDisplayGroup.defaultMargins = 0;\nDisplayGroup.instances = [];\nDisplayGroup.activeInstances = [];\nDisplayGroup.defaults = {\n    ishor: true,\n    marginHor: DisplayGroup.defaultMargins,\n    marginVer: DisplayGroup.defaultMargins,\n};\nDisplayGroup.argMap = {\n    string: [\"label\"],\n    boolean: [\"ishor\"],\n    number: [\"marginHor\", \"marginVer\"],\n    dim: [\"dim\"],\n    Overlay: [\"overlay\"]\n};\nDisplayGroup.argCustomTypes = [];\nfunction h(...Arguments) {\n    return new DisplayCell(new DisplayGroup(...Arguments));\n    // let displaycell = new DisplayCell(new DisplayGroup(...Arguments) );\n    // if (displaycell.displaygroup.dim) displaycell.dim = displaycell.displaygroup.dim;\n    // return displaycell;\n}\nfunction v(...Arguments) {\n    return new DisplayCell(new DisplayGroup(false, ...Arguments));\n    // let displaycell = new DisplayCell(new DisplayGroup(false, ...Arguments) );\n    // if (displaycell.displaygroup.dim) displaycell.dim = displaycell.displaygroup.dim;\n    // return displaycell;\n}\n// export {v, h, DisplayGroup}\n// import {Base} from './Base';\n// import {Coord} from './Coord';\n// import {DisplayCell} from './DisplayCell';\n// import {Css} from './Css';\n// import {DisplayGroup} from './DisplayGroup';\n// import {HtmlBlock} from './htmlBlock';\n// import {Observe} from './Observe'\n// import {Overlay} from './Overlay';\n// import {Pages} from './Pages';\n// import {mf, pf} from './PureFunctions';\n// import {ScrollBar} from './ScrollBar';\nclass Handler extends Base {\n    constructor(...Arguments) {\n        super();\n        this.rootCell = undefined;\n        this.buildBase(...Arguments);\n        Handler.updateScreenSize();\n        if (\"DisplayCell\" in this.retArgs)\n            this.rootCell = this.retArgs[\"DisplayCell\"][0];\n        else\n            pf.errorHandling(`Handler \"${this.label}\" requires a DisplayCell`);\n        if (this.handlerMargin == undefined)\n            this.handlerMargin = Handler.handlerMarginDefault;\n        if (Handler.firstRun) {\n            setTimeout(Handler.update);\n            Handler.firstRun = false;\n            for (let element of document.querySelectorAll(Css.deleteOnFirstRunClassname))\n                element.remove();\n            window.onresize = function () { Handler.update(); };\n            window.onwheel = function (event) { ScrollBar.onWheel(event); };\n            window.addEventListener(\"popstate\", function (event) { Pages.popstate(event); });\n            Pages.parseURL();\n        }\n        if (this.addThisHandlerToStack) {\n            Handler.activeInstances.push(this);\n        }\n        Handler.makeLabel(this);\n        Handler.update( /* [this] */);\n        Css.update();\n    }\n    pop() { return Handler.pop(this); }\n    toTop() {\n        let index = Handler.activeInstances.indexOf(this);\n        if (index > -1 && index != Handler.activeInstances.length - 1) {\n            Handler.activeInstances.splice(index, 1);\n            Handler.activeInstances.push(this);\n            Handler.update();\n        }\n    }\n    static pop(handlerInstance = Handler.activeInstances[Handler.activeInstances.length - 1]) {\n        let index = Handler.activeInstances.indexOf(handlerInstance);\n        let poppedInstance = undefined;\n        if (index != -1) {\n            poppedInstance = Handler.activeInstances[index];\n            Handler.update([handlerInstance], index, true);\n            Handler.activeInstances.splice(index, 1);\n        }\n        return poppedInstance;\n    }\n    static screensizeToCoord(dislaycell, handlerMargin) {\n        let viewport = pf.viewport();\n        dislaycell.coord.assign(handlerMargin, handlerMargin, viewport[0] - handlerMargin * 2, viewport[1] - handlerMargin * 2, handlerMargin, handlerMargin, viewport[0] - handlerMargin * 2, viewport[1] - handlerMargin * 2, Handler.currentZindex);\n        //dislaycell.coord.copy(handlerMargin, handlerMargin, viewport[0]-handlerMargin*2, viewport[1]-handlerMargin*2, Handler.currentZindex);\n    }\n    static updateScreenSize() {\n        let [width, height] = pf.viewport();\n        Handler.screenSizeCoord.assign(0, 0, width, height, 0, 0, width, height, 0);\n    }\n    static update(ArrayofHandlerInstances = Handler.activeInstances, instanceNo = 0, derender = false) {\n        // console.log(\"Update Fired\");\n        Handler.updateScreenSize();\n        Handler.renderAgain = false;\n        Pages.activePages = [];\n        Handler.currentZindex = Handler.handlerZindexStart + (Handler.handlerZindexIncrement) * instanceNo;\n        for (let index = 0; index < ArrayofHandlerInstances.length; index++) {\n            let handlerInstance = ArrayofHandlerInstances[index];\n            if (handlerInstance.preRenderCallback)\n                handlerInstance.preRenderCallback(handlerInstance);\n            if (handlerInstance.coord) {\n                handlerInstance.rootCell.coord.copy(handlerInstance.coord);\n            }\n            else {\n                Handler.screensizeToCoord(handlerInstance.rootCell, handlerInstance.handlerMargin);\n            }\n            Handler.renderDisplayCell(handlerInstance.rootCell, undefined, undefined, derender);\n            instanceNo += 1;\n            Handler.currentZindex = Handler.handlerZindexStart + (Handler.handlerZindexIncrement) * instanceNo;\n            if (handlerInstance.postRenderCallback)\n                handlerInstance.postRenderCallback(handlerInstance);\n        }\n        if (Pages.activePages.length)\n            Pages.applyOnclick();\n        Observe.update();\n        if (Handler.renderAgain)\n            console.log(\"REDNDER AGAIN!\");\n    }\n    static renderDisplayCell(displaycell, parentDisplaygroup /*= undefined*/, index /*= undefined*/, derender) {\n        if (displaycell.coord.offset)\n            Handler.activeOffset = true;\n        if (displaycell.preRenderCallback)\n            displaycell.preRenderCallback(displaycell, parentDisplaygroup, index, derender);\n        if (derender)\n            Observe.derender(displaycell);\n        let pages = displaycell.pages;\n        if (pages) {\n            if (!derender)\n                Pages.activePages.push(pages);\n            let evalCurrentPage = pages.eval();\n            if (evalCurrentPage != pages.previousPage) { // derender old page here\n                pages.displaycells[pages.previousPage].coord.copy(displaycell.coord);\n                Handler.renderDisplayCell(pages.displaycells[pages.previousPage], parentDisplaygroup, index, true);\n                pages.currentPage = pages.previousPage = evalCurrentPage;\n                Pages.pushHistory();\n            }\n            pages.displaycells[evalCurrentPage].coord.copy(displaycell.coord);\n            Handler.renderDisplayCell(pages.displaycells[evalCurrentPage], parentDisplaygroup, index, derender);\n            pages.currentPage = evalCurrentPage;\n            pages.addSelected();\n        }\n        else {\n            let htmlBlock = displaycell.htmlBlock;\n            let displaygroup = displaycell.displaygroup;\n            // let overlays = displaycell.overlays;\n            if (htmlBlock) {\n                Handler.renderHtmlBlock(displaycell, derender, parentDisplaygroup);\n            }\n            if (displaygroup) {\n                displaygroup.coord.copy(displaycell.coord);\n                if (displaygroup && htmlBlock) {\n                    Handler.currentZindex += Handler.zindexIncrement;\n                    displaycell.coord.applyMargins(pf.uis0(htmlBlock.marginLeft), pf.uis0(htmlBlock.marginTop), pf.uis0(htmlBlock.marginRight), pf.uis0(htmlBlock.marginBottom));\n                }\n                Handler.renderDisplayGroup(displaycell, derender);\n            }\n        }\n        if (displaycell.overlays.length) {\n            for (let ovlay of displaycell.overlays) {\n                // console.log(\"rendering\",displaycell.label)\n                ovlay.renderOverlay(displaycell, parentDisplaygroup, index, derender);\n            }\n        }\n        // if (derender) displaycell.coord.within.reset();\n        if (displaycell.postRenderCallback)\n            displaycell.postRenderCallback(displaycell, parentDisplaygroup, index, derender);\n        if (displaycell.coord.offset)\n            Handler.activeOffset = false;\n    }\n    static renderDisplayGroup(parentDisplaycell, derender) {\n        let displaygroup = parentDisplaycell.displaygroup;\n        let ishor = displaygroup.ishor;\n        let coord = displaygroup.coord;\n        let cellArraylength = displaygroup.cellArray.length;\n        let marginpx = (ishor) ? displaygroup.marginHor * (cellArraylength - 1) : displaygroup.marginVer * (cellArraylength - 1);\n        let maxpx = (ishor) ? coord.width - marginpx : coord.height - marginpx;\n        let cellsizepx;\n        let totalFixedpx = displaygroup.totalPx();\n        let pxForPercent = maxpx - totalFixedpx;\n        let totalPercent = 0;\n        let DisplayCellPercent = 0;\n        let displayCellPx;\n        let pxForPercentLeft = pxForPercent;\n        let overlay = displaygroup.overlay;\n        // create dim array;\n        // let isValid = true;\n        let dimArray = [];\n        // let dimArrayTotal = 0;\n        // create dim array - Initialize.\n        for (let index = 0; index < cellArraylength; index++) {\n            let displaycell = displaygroup.cellArray[index];\n            let dim = displaycell.dim;\n            let min = ((pf.isTypePx(displaycell.dim)) ? pf.pxAsNumber(displaycell.dim) : displaycell.minDisplayGroupSize);\n            let px = (pf.isTypePx(displaycell.dim) ? pf.pxAsNumber(displaycell.dim) : pf.percentAsNumber(displaycell.dim) * pxForPercent / 100);\n            // dimArrayTotal += px;            \n            dimArray.push({ dim, min, px });\n        }\n        // loop until all % are worked out\n        let percentReballancingRequired;\n        let dimArrayTotal;\n        do {\n            // If % less than min... assign it min\n            percentReballancingRequired = false;\n            let fixedPixels = 0;\n            dimArrayTotal = 0;\n            for (let index = 0; index < dimArray.length; index++) {\n                let dimObj = dimArray[index];\n                if (dimObj.px < dimObj.min) {\n                    dimObj.px = dimObj.min;\n                    dimObj.dim = `${dimObj.px}px`;\n                    percentReballancingRequired = true;\n                }\n                fixedPixels += (pf.isTypePx(dimObj.dim) ? dimObj.px : 0);\n                dimArrayTotal += dimObj.px;\n            }\n            let px4Percent = maxpx - fixedPixels; // key\n            //console.log(`maxpx: ${maxpx} fixedPixels: ${fixedPixels} px4Percent:${px4Percent}`)\n            // console.log(maxpx, fixedPixels, px4Percent)\n            // if min was assigned - rebalance\n            if (percentReballancingRequired) {\n                let currentPercent = 0;\n                // calculate total percent (so less than 100)\n                for (let index = 0; index < dimArray.length; index++) {\n                    let dimObj = dimArray[index];\n                    if (pf.isTypePercent(dimObj.dim)) {\n                        currentPercent += pf.percentAsNumber(dimObj.dim);\n                    }\n                }\n                let mult = 100 / currentPercent;\n                // and apply the difference over this code.\n                dimArrayTotal = 0;\n                for (let index = 0; index < dimArray.length; index++) {\n                    let dimObj = dimArray[index];\n                    if (pf.isTypePercent(dimObj.dim)) {\n                        dimObj.dim = `${pf.percentAsNumber(dimObj.dim) * mult}%`;\n                        dimObj.px = pf.percentAsNumber(dimObj.dim) * px4Percent / 100;\n                        //console.log(`percent ${pf.percentAsNumber(dimObj.dim)} * ${px4Percent}/100 = ${dimObj.px}`)\n                    }\n                    dimArrayTotal += dimObj.px;\n                }\n            }\n        } while (percentReballancingRequired);\n        //console.log(`Final dimarrayTotal ${dimArrayTotal} of ${maxpx}`, JSON.stringify(dimArray, null, 3));\n        // this part opens and/or closes the scrollbar overlay\n        if (pxForPercent < 0) {\n            // console.log(pxForPercent)\n            if (!overlay) {\n                displaygroup.overlay = new Overlay(\"ScrollBar\", `${displaygroup.label}_ScrollBar`, displaygroup, totalFixedpx, maxpx);\n            }\n            displaygroup.overlay.renderOverlay(parentDisplaycell, displaygroup, 0, false);\n            let dgCoord = displaygroup.coord;\n            let scrollbar = displaygroup.overlay.returnObj;\n            let scrollWidth = scrollbar.scrollWidth;\n            dgCoord.width -= (ishor) ? 0 : scrollWidth;\n            dgCoord.within.width -= (ishor) ? 0 : scrollWidth;\n            dgCoord.height -= (ishor) ? scrollWidth : 0;\n            dgCoord.within.height -= (ishor) ? scrollWidth : 0;\n        }\n        else {\n            if (overlay) {\n                if (overlay.currentlyRendered)\n                    displaygroup.overlay.renderOverlay(parentDisplaycell, displaygroup, 0, true);\n            }\n        }\n        let x = displaygroup.coord.x;\n        let y = displaygroup.coord.y;\n        let width;\n        let height;\n        // apply scrollbar offset\n        if (displaygroup.overlay) {\n            displaygroup.offset = displaygroup.overlay.returnObj[\"offset\"];\n            x -= (ishor) ? displaygroup.offset : 0;\n            y -= (ishor) ? 0 : displaygroup.offset;\n        }\n        // this part loops the displaycells in cellarray\n        for (let index = 0; index < cellArraylength; index++) {\n            let displaycell = displaygroup.cellArray[index];\n            if (pf.isTypePercent(displaycell.dim)) {\n                DisplayCellPercent = pf.percentAsNumber(displaycell.dim);\n                totalPercent += DisplayCellPercent;\n                if (totalPercent <= 100.01) {\n                    displayCellPx = Math.round(pxForPercent * DisplayCellPercent / 100.0);\n                    pxForPercentLeft -= displayCellPx;\n                }\n                else {\n                    displayCellPx = pxForPercentLeft;\n                }\n            }\n            cellsizepx = (pf.isTypePx(displaycell.dim)) ? (pf.pxAsNumber(displaycell.dim)) : displayCellPx;\n            width = (ishor) ? cellsizepx : coord.width;\n            height = (ishor) ? coord.height : cellsizepx;\n            displaycell.coord.assign(x, y, width, height, undefined, undefined, undefined, undefined, Handler.currentZindex);\n            displaycell.coord.cropWithin(displaygroup.coord.within);\n            Handler.renderDisplayCell(displaycell, displaygroup, index, derender);\n            x += (ishor) ? width + displaygroup.marginHor : 0;\n            y += (ishor) ? 0 : height + displaygroup.marginVer;\n        }\n    }\n    // static createDimArray(){}\n    static renderHtmlBlock(displaycell, derender = false, parentDisplaygroup) {\n        let htmlBlock = displaycell.htmlBlock;\n        let el = pf.elExists(displaycell.label);\n        let alreadyexists = (el) ? true : false;\n        // if (htmlBlock.label == \"Example01_javascript\"){\n        //     console.log(htmlBlock);\n        //     console.log(\"Already Exists: \"+alreadyexists)\n        // }\n        // let derenderPre = derender;\n        derender = displaycell.coord.derender(derender);\n        // if (derenderPre == false && derender == true)\n        //      console.log(displaycell.label + \"out of zone\", displaycell.coord);\n        let isNulDiv = (htmlBlock.css.trim() == \"\" &&\n            htmlBlock.innerHTML.trim() == \"\" &&\n            Object.keys(htmlBlock.attributes).length == 0 &&\n            !Handler.renderNullObjects);\n        if (derender || isNulDiv) {\n            if (alreadyexists)\n                el.remove();\n            // htmlBlock.el = undefined;\n        }\n        else {\n            if (!alreadyexists)\n                el = document.createElement(htmlBlock.tag);\n            pf.setAttrib(el, \"id\", displaycell.label);\n            if (htmlBlock.css.trim())\n                pf.setAttrib(el, \"class\", htmlBlock.css);\n            Handler.renderHtmlAttributes(el, htmlBlock, displaycell.label);\n            if (el.innerHTML != htmlBlock.innerHTML)\n                el.innerHTML = htmlBlock.innerHTML;\n            if (!alreadyexists) {\n                document.body.appendChild(el);\n                htmlBlock.el = el;\n                if (htmlBlock.events)\n                    htmlBlock.events.applyToHtmlBlock(htmlBlock);\n            }\n            let attrstring = displaycell.coord.newAsAttributeString(); // + clipString;\n            if (el.style.cssText != attrstring)\n                el.style.cssText = attrstring;\n        }\n    }\n    static renderHtmlAttributes(el, htmlblock, id) {\n        for (let key in htmlblock.attributes) {\n            let value = htmlblock.attributes[key];\n            if (key == \"class\")\n                value += \" \" + htmlblock.css;\n            if (key == \"id\")\n                value = id;\n            pf.setAttrib(el, key, value);\n        }\n        pf.setAttrib(el, \"llm\", \"\");\n    }\n}\nHandler.handlerMarginDefault = 0;\nHandler.firstRun = true;\nHandler.instances = [];\nHandler.activeInstances = [];\nHandler.defaults = {\n    cssString: \" \",\n    addThisHandlerToStack: true,\n    controlledBySomething: false,\n    activeOffset: false,\n};\nHandler.argMap = {\n    string: [\"label\"],\n    number: [\"handlerMargin\"],\n    Coord: [\"coord\"],\n    function: [\"preRenderCallback\", \"postRenderCallback\"],\n    boolean: [\"addThisHandlerToStack\"]\n};\nHandler.screenSizeCoord = new Coord();\nHandler.renderNullObjects = false;\nHandler.argCustomTypes = [];\nHandler.handlerZindexStart = 1;\nHandler.zindexIncrement = 1;\nHandler.handlerZindexIncrement = 100;\nfunction H(...Arguments) {\n    return new Handler(...Arguments);\n}\n// export {H, Handler}\n// import {BaseF, Base} from './Base';\n// import {mf, pf} from './PureFunctions';\nclass Css extends Base {\n    constructor(...Arguments) {\n        super();\n        this.buildBase(...Arguments);\n        if (this.cssObj == undefined) {\n            this.cssObj = this.makeObj();\n            this.css = this.makeString();\n        }\n        if (this.cssHover) {\n            this.cssHoverObj = this.makeObj(this.cssHover);\n            this.cssHover = this.makeString(this.cssHoverObj, \"hover\");\n        }\n        if (this.cssSelect) {\n            this.cssSelectObj = this.makeObj(this.cssSelect);\n            this.cssSelect = this.makeString(this.cssSelectObj, \"\", \"Selected\");\n        }\n    }\n    static byLabel(classname) {\n        for (let key in Css.instances)\n            if (Css.instances[key].classname == classname)\n                return Css.instances[key];\n        return undefined;\n    }\n    makeString(obj = this.cssObj, postfix = \"\", addToClassName = \"\") {\n        let returnString = `${(this.isClassname) ? \".\" : \"\"}${this.classname}${addToClassName}${(postfix) ? \":\" + postfix : \"\"} {\\n`;\n        for (let key in obj)\n            returnString += `  ${key}:${obj[key]};\\n`;\n        returnString += \"}\";\n        return returnString;\n    }\n    makeObj(str = this.css) {\n        //let str = this.asString;\n        let obj = {};\n        if (str.indexOf('{') > -1) {\n            str = str.split('{')[1];\n            str = str.split('}')[0];\n        }\n        let strArray = str.split(';');\n        let index;\n        let arr;\n        for (let ele of strArray) {\n            index = ele.indexOf(':');\n            if (index > -1) {\n                arr = ele.split(':');\n                obj[arr[0].trim()] = arr[1].trim();\n            }\n        }\n        return obj;\n    }\n    static byname(css) {\n        for (let cssInstance of Css.instances)\n            if (cssInstance.css == css)\n                return cssInstance;\n        return undefined;\n    }\n    static update() {\n        let style = document.getElementById(Css.elementId);\n        let alreadyexists = true;\n        if (!style) {\n            alreadyexists = false;\n            style = document.createElement('style');\n        }\n        pf.setAttrib(style, \"id\", Css.elementId);\n        let outstring = \"\\n\";\n        for (let instance of Css.instances) {\n            if (instance.css) {\n                outstring += instance.css + \"\\n\";\n            }\n            if (instance.cssHover) {\n                outstring += instance.cssHover + \"\\n\";\n            }\n            if (instance.cssSelect) {\n                outstring += instance.cssSelect + \"\\n\";\n            }\n        }\n        style.innerHTML = outstring;\n        if (!alreadyexists)\n            document.getElementsByTagName('head')[0].appendChild(style);\n    }\n}\nCss.elementId = \"llmStyle\";\nCss.instances = [];\nCss.activeInstances = [];\nCss.defaults = {\n    css: function () { return `Css_${pf.pad_with_zeroes(Css.instances.length)}`; },\n    isClassname: true\n};\nCss.argMap = {\n    string: [\"classname\", \"css\", \"cssHover\", \"cssSelect\", \"cssSelectHover\"],\n    boolean: [\"isClassname\"]\n};\nCss.deleteOnFirstRunClassname = \".remove\";\nfunction css(...Arguments) { return new Css(...Arguments); }\n// export {Css, css}\n// import {Css, css} from './Css'\nclass DefaultTheme {\n}\nDefaultTheme.advisedDiv = new Css(\"div[llm]\", \"position:absolute;\", false);\nDefaultTheme.advisedBody = new Css(\"body\", \"overflow: hidden;\", false);\n// context\nDefaultTheme.context = css(\"contxt\", \"background-color:white;color: black;outline-style: solid;outline-width: 1px;\", \"contxt:hover\", \"background-color:black;color: white;outline-style: solid;outline-width: 1px;\");\nCss.theme = DefaultTheme;\n// export {DefaultTheme}\n// import {Base} from './Base';\n// import {DisplayCell} from './DisplayCell';\n// import {Handler} from './Handler';\n// import {Css, css} from './Css';\n// import {mf, pf} from './PureFunctions';\n// import {Tree, tree} from './Tree';\nclass Pages extends Base {\n    constructor(...Arguments) {\n        super();\n        this.buildBase(...Arguments);\n        Pages.pop(this);\n        Pages.instances.unshift(this);\n        if (this.retArgs[\"DisplayCell\"])\n            this.displaycells = this.retArgs[\"DisplayCell\"];\n        else\n            pf.errorHandling(\"Pages Requires at least one DisplayCells\");\n        Pages.makeLabel(this);\n    }\n    eval() { return this.evalFunction(this); }\n    evalCell() { return this.displaycells[this.eval()]; }\n    setPage(pageNumber) {\n        if (pageNumber != this.currentPage) {\n            // this.previousPage = this.currentPage;\n            this.currentPage = pageNumber;\n            Handler.update();\n        }\n    }\n    addSelected(pageNumber = this.currentPage) {\n        let querry = document.querySelectorAll(`[pagebutton='${this.label}|${pageNumber}']`);\n        let el;\n        let select;\n        for (let i = 0; i < querry.length; i++) {\n            el = querry[i];\n            select = el.getAttribute(\"select\");\n            if (select)\n                pf.setAttrib(el, \"class\", select);\n            else {\n                let currentClass = el.getAttribute(\"class\");\n                if (Css.byLabel(currentClass).cssSelect) {\n                    pf.setAttrib(el, \"class\", currentClass + \"Selected\");\n                }\n            }\n        }\n        // console.log(el);\n    }\n    static setPage(label, pageNumber) { Pages.byLabel(label).setPage(pageNumber); }\n    static applyOnclick() {\n        let querry = document.querySelectorAll(`[pagebutton]`);\n        let value;\n        let valueArray;\n        let pagename;\n        let pageNo;\n        let el;\n        let THIS = this;\n        for (let i = 0; i < querry.length; i++) {\n            el = (querry[i]);\n            el.onclick = function (event) { Tree.onclick.bind(this)(event); };\n        }\n    }\n    indexByName(name) {\n        for (let index = 0; index < this.displaycells.length; index++) {\n            const displaycell = this.displaycells[index];\n            if (displaycell.label == name)\n                return index;\n        }\n        return -1;\n    }\n    static button(pagename, index) {\n        // let page = Pages.byLabel(pagename);\n        // let newIndex:number\n        // if (typeof(index) == \"string\") {\n        //     newIndex = page.indexByName(index);\n        //     if (newIndex == -1) {\n        //         console.log(`Pages.button -> no page called ${index}`);\n        //         return {}\n        //     }\n        //     index = newIndex;\n        // }\n        return { attributes: { pagebutton: `${pagename}|${index}` } };\n    }\n    static parseURL(url = window.location.href) {\n        let argsObj = pf.parseURLParams(url);\n        if (argsObj)\n            for (let key in argsObj) {\n                let pageInstance = Pages.byLabel(key);\n                if (pageInstance)\n                    pageInstance.currentPage = argsObj[key];\n            }\n    }\n    static pushHistory() {\n        let newUrl = window.location.href.split(\"?\")[0];\n        let prefix = \"?\";\n        for (const page of Pages.activePages) {\n            if (page.currentPage) {\n                newUrl += `${prefix}${page.label}=${page.currentPage}`;\n                prefix = \"&\";\n            }\n        }\n        history.pushState(null, null, newUrl);\n        //console.log(newUrl);\n    }\n    static popstate(event) {\n        // history.back();\n        for (let index = 0; index < Pages.activePages.length; index++) {\n            const page = Pages.activePages[index];\n            page.currentPage = 0;\n        }\n        Pages.parseURL();\n        Handler.update();\n    }\n}\nPages.activePages = [];\nPages.instances = [];\nPages.activeInstances = [];\nPages.defaults = {\n    currentPage: 0, previousPage: 0,\n    evalFunction: function (thisPages) { return thisPages.currentPage; }\n};\nPages.argMap = {\n    string: [\"label\"],\n    number: [\"currentPage\"],\n    function: [\"evalFunction\"],\n    dim: [\"dim\"],\n    // DisplayCell: [\"displaycells\"] <- but the whole array done in constructor\n};\nfunction P(...Arguments) {\n    let displaycell = new DisplayCell(new Pages(...Arguments));\n    if (displaycell.pages.dim)\n        displaycell.dim = displaycell.pages.dim;\n    return displaycell;\n}\n// export {P, Pages}\n// import { Base } from './Base';\nclass Drag extends Base {\n    constructor(...Arguments) {\n        super();\n        this.onDown = function () { };\n        this.onMove = function () { };\n        this.onUp = function () { };\n        this.isDown = false;\n        this.buildBase(...Arguments);\n        if (\"Array\" in this.retArgs) {\n            let array = this.retArgs[\"Array\"][0];\n            this.onDown = array[0];\n            this.onMove = array[1];\n            this.onUp = array[2];\n        }\n        if (\"HTMLDivElement\" in this.retArgs) {\n            this.el = this.retArgs[\"HTMLDivElement\"][0];\n        }\n        let THIS = this;\n        this.el.onmousedown = function (e) {\n            THIS.onDown();\n            THIS.isDown = true;\n            THIS.mousePos = { x: e.clientX, y: e.clientY };\n            window.addEventListener('selectstart', Drag.disableSelect);\n            window.onmousemove = function (e) {\n                THIS.mouseDiff = { x: e.clientX - THIS.mousePos[\"x\"], y: e.clientY - THIS.mousePos[\"y\"] };\n                THIS.onMove(THIS.mouseDiff);\n            };\n            window.onmouseup = function (e) {\n                THIS.reset();\n                THIS.onUp(THIS.mouseDiff);\n            };\n        };\n        Drag.makeLabel(this);\n    }\n    reset() {\n        window.onmousemove = function () { };\n        window.onmouseup = function () { };\n        window.removeEventListener('selectstart', Drag.disableSelect);\n        this.isDown = false;\n    }\n    static disableSelect(event) {\n        event.preventDefault();\n    }\n}\nDrag.instances = [];\nDrag.activeInstances = [];\nDrag.defaults = {};\nDrag.argMap = {\n    string: [\"label\"],\n};\nclass Swipe extends Base {\n    constructor(...Arguments) {\n        super();\n        this.buildBase(...Arguments);\n        Swipe.makeLabel(this);\n    }\n}\nSwipe.swipeDistance = 50;\nSwipe.elementId = \"llmSwipe\";\nSwipe.instances = [];\nSwipe.activeInstances = [];\nSwipe.defaults = {\n    swipeDistance: Swipe.swipeDistance\n};\nSwipe.argMap = {\n    string: [\"label\"],\n    number: [\"swipeDistance\"]\n};\nfunction swipe(...Arguments) {\n    let swipeObj = new Swipe(...Arguments);\n    let retObj = { onMove: function (offset) {\n            let dragObj = this;\n            if (swipeObj[\"left\"] && (offset[\"x\"] < -swipeObj.swipeDistance)) {\n                swipeObj[\"left\"]();\n                dragObj.reset();\n            }\n            if (swipeObj[\"right\"] && (offset[\"x\"] > swipeObj.swipeDistance)) {\n                swipeObj[\"right\"]();\n                dragObj.reset();\n            }\n            if (swipeObj[\"up\"] && (offset[\"y\"] < -swipeObj.swipeDistance)) {\n                swipeObj[\"up\"]();\n                dragObj.reset();\n            }\n            if (swipeObj[\"down\"] && (offset[\"y\"] > swipeObj.swipeDistance)) {\n                swipeObj[\"down\"]();\n                dragObj.reset();\n            }\n        } };\n    return retObj;\n}\n// export {swipe, Swipe, Drag}\n// import {Base} from './Base';\nclass Hold extends Base {\n    constructor(...Arguments) {\n        super();\n        this.onDown = function () { };\n        this.event = function () { };\n        this.onUp = function () { };\n        this.isDown = false;\n        this.buildBase(...Arguments);\n        if (\"HTMLDivElement\" in this.retArgs) {\n            this.el = this.retArgs[\"HTMLDivElement\"][0];\n        }\n        let THIS = this;\n        this.el.onmousedown = function (e) {\n            THIS.onDown();\n            // console.log(THIS.doOnclick);\n            THIS.isDown = true;\n            if (THIS.doOnclick)\n                THIS.event();\n            setTimeout(function () { Hold.start(THIS); }, THIS.startTime);\n            window.onmouseup = function (e) {\n                THIS.onUp();\n                THIS.isDown = false;\n            };\n        };\n        Hold.makeLabel(this);\n    }\n    static start(THIS) {\n        if (THIS.isDown) {\n            THIS.event();\n            setTimeout(function () { Hold.start(THIS); }, THIS.repeatTime);\n        }\n    }\n}\nHold.instances = [];\nHold.activeInstances = [];\nHold.defaults = {\n    startTime: 1000, repeatTime: 100, doOnclick: true\n};\nHold.argMap = {\n    string: [\"label\"],\n};\n// export {Hold}\n// import {DisplayCell} from './DisplayCell';\n// import {DisplayGroup} from './DisplayGroup';\n// import {mf, pf} from './PureFunctions';\nclass Overlay {\n    constructor(...Arguments) {\n        Overlay.instances.push(this);\n        // console.log(\"New Overlay!\");\n        this.label = `Overlay_${pf.pad_with_zeroes(Overlay.instances.length)}`;\n        this.sourceClassName = Arguments.shift();\n        this.returnObj = new (Overlay.classes[this.sourceClassName])(...Arguments);\n    }\n    static byLabel(label) {\n        for (let key in Overlay.instances)\n            if (Overlay.instances[key].label == label)\n                return Overlay.instances[key];\n        return undefined;\n    }\n    renderOverlay(displaycell, parentDisplaygroup, index, derender) {\n        this.currentlyRendered = !derender;\n        // console.log(\"render\",this.returnObj[\"label\"]);\n        (this.returnObj[\"render\"])(displaycell, parentDisplaygroup, index, derender);\n    }\n}\nOverlay.instances = [];\nOverlay.classes = {\n//    DragBar,for wxample... filled in when modules load.\n};\n// export {Overlay}\n// import { Base } from './Base';\n// import {Css, css} from './Css';\n// import {I, DisplayCell} from './DisplayCell';\n// import {DisplayGroup, h, v} from './DisplayGroup';\n// import {Coord} from './Coord';\n// import {Events, events} from './Events';\n// import {Handler} from './Handler';\n// import {Overlay} from './Overlay';\n// import {mf, pf} from './PureFunctions';\nclass DragBar extends Base {\n    constructor(...Arguments) {\n        super();\n        this.buildBase(...Arguments);\n        let dragbar = this;\n        this.displaycell = I(`${this.label}_dragbar`, \"\", events({ ondrag: { onDown: function (xmouseDiff) {\n                    if (pf.isTypePercent(dragbar.parentDisplaycell.dim)) {\n                        dragbar.parentDisplaygroup.percentToPx(dragbar.parentDisplaycell);\n                    }\n                    dragbar.startpos = pf.pxAsNumber(dragbar.parentDisplaycell.dim);\n                },\n                onMove: function (xmouseDiff) {\n                    let newdim = dragbar.startpos + ((dragbar.ishor) ? xmouseDiff[\"x\"] : xmouseDiff[\"y\"]) * ((dragbar.isLast) ? -1 : 1);\n                    if (newdim > dragbar.max)\n                        newdim = dragbar.max;\n                    if (newdim < dragbar.min)\n                        newdim = dragbar.min;\n                    dragbar.parentDisplaycell.dim = `${newdim}px`;\n                    Handler.update();\n                },\n                // onUp: function(ouxmouseDifftput:object){}\n            } }));\n        DragBar.makeLabel(this);\n    }\n    render(displaycell, parentDisplaygroup, index, derender) {\n        // console.log(parentDisplaygroup);\n        if (!this.parentDisplaygroup)\n            this.parentDisplaygroup = parentDisplaygroup;\n        let dragbar = this;\n        let dragcell = dragbar.displaycell;\n        let ishor = parentDisplaygroup.ishor;\n        dragbar.ishor = ishor;\n        let pxsize = (dragbar.pxsize) ? dragbar.pxsize : ((ishor) ? parentDisplaygroup.marginHor : parentDisplaygroup.marginVer);\n        let isLast = (index == parentDisplaygroup.cellArray.length - 1) ? true : false;\n        dragbar.isLast = isLast;\n        let pcoord = displaycell.coord;\n        let x = (ishor) ? ((isLast) ? pcoord.x - pxsize : pcoord.x + pcoord.width) : pcoord.x;\n        let y = (ishor) ? pcoord.y : ((isLast) ? pcoord.y - pxsize : pcoord.y + pcoord.height);\n        let width = (ishor) ? pxsize : pcoord.width;\n        let height = (ishor) ? pcoord.height : pxsize;\n        dragcell.coord.assign(x, y, width, height, undefined, undefined, undefined, undefined, Handler.currentZindex + Handler.zindexIncrement);\n        dragcell.htmlBlock.css = (ishor) ? dragbar.horcss.classname : dragbar.vercss.classname;\n        if (parentDisplaygroup.coord.isCoordCompletelyOutside(dragcell.coord))\n            derender = true;\n        Handler.renderDisplayCell(dragcell, parentDisplaygroup, undefined, derender);\n    }\n}\nDragBar.horCss = css(\"db_hor\", \"background-color:black;cursor: ew-resize;\");\nDragBar.verCss = css(\"db_ver\", \"background-color:black;cursor: ns-resize;\");\nDragBar.instances = [];\nDragBar.activeInstances = [];\nDragBar.defaults = {\n    horcss: DragBar.horCss,\n    vercss: DragBar.verCss\n};\nDragBar.argMap = {\n    string: [\"label\"],\n    DisplayCell: [\"parentDisplaycell\"],\n    number: [\"min\", \"max\", \"pxsize\"],\n    Css: [\"horcss\", \"vercss\"]\n};\nfunction dragbar(...Arguments) {\n    let overlay = new Overlay(\"DragBar\", ...Arguments);\n    let newDragBar = overlay.returnObj;\n    let parentDisplaycell = newDragBar.parentDisplaycell;\n    // parentDisplaycell.overlay = overlay; // remove this line soon\n    parentDisplaycell.addOverlay(overlay);\n    return parentDisplaycell;\n}\nOverlay.classes[\"DragBar\"] = DragBar;\n// export {dragbar, DragBar}\n// import {Base} from './Base';\n// import {Css, css} from './Css';\n// import {DisplayCell, I} from './DisplayCell';\n// import {DisplayGroup, v, h} from './DisplayGroup';\n// import {Events, events} from './Events';\n// import {Coord} from './Coord';\n// import {Handler} from './Handler';\n// import {Overlay} from './Overlay';\nclass ScrollBar extends Base {\n    constructor(...Arguments) {\n        super();\n        this.buildBase(...Arguments);\n        ScrollBar.makeLabel(this);\n        this.build();\n    }\n    build() {\n        let THIS = this;\n        let off = this.arrowOffset;\n        let ss = this.scrollWidth;\n        let w = ss - off;\n        let mid = ss / 2;\n        this.leftArrow = I(this.label + \"_Left\", `<svg height=\"${ss}\" width=\"${ss}\">\r\n            <polygon points=\"${off},${mid} ${w},${off} ${w},${w} ${off},${mid}\"\r\n            style=\"fill:black;stroke:black;stroke-width:1\" />\r\n            </svg>`, `${ss}px`, \"whiteBG\", events({ onhold: { event: function (mouseEvent) { THIS.clickLeftorUp(mouseEvent); } }\n        }));\n        this.upArrow = I(this.label + \"_Up\", `<svg height=\"${ss}\" width=\"${ss}\">\r\n            <polygon points=\"${off},${w} ${mid},${off} ${w},${w} ${off},${w}\"\r\n            style=\"fill:black;stroke:black;stroke-width:1\" />\r\n            </svg>`, `${ss}px`, \"whiteBG\", events({ onhold: { event: function (mouseEvent) { THIS.clickLeftorUp(mouseEvent); } }\n        }));\n        this.prePaddle = I(this.label + \"_Pre\", \"\", \"whiteBG\", events({ onclick: function (mouseEvent) { THIS.clickPageLeftorUp(mouseEvent); } }));\n        this.paddle = I(this.label + \"_Paddle\", \"\", \"blackBG\", events({ ondrag: { onDown: function () { THIS.offsetAtDrag = THIS.offset; }, onMove: function (output) { THIS.dragging(output); },\n                /* onUp: function(output:object){console.log(\"mouseup\");console.log(output)}*/\n            }\n        }));\n        this.postPaddle = I(this.label + \"_Post\", \"\", \"whiteBG\", events({ onclick: function (mouseEvent) { THIS.clickPageRightOrDown(mouseEvent); } }));\n        this.rightArrow = I(this.label + \"_Right\", `<svg height=\"${ss}\" width=\"${ss}\">\r\n            <polygon points=\"${off},${off} ${w},${mid} ${off},${w} ${off},${off}\"\r\n            style=\"fill:black;stroke:black;stroke-width:1\" />\r\n            </svg>`, `${ss}px`, \"whiteBG\", events({ onhold: { event: function (mouseEvent) { THIS.clickRightOrDown(mouseEvent); } }\n        }));\n        this.downArrow = I(this.label + \"_down\", `<svg height=\"${ss}\" width=\"${ss}\">\r\n            <polygon points=\"${off},${off} ${w},${off} ${mid},${w} ${off},${off}\"\r\n            style=\"fill:black;stroke:black;stroke-width:1\" />\r\n            </svg>`, `${ss}px`, \"whiteBG\", events({ onhold: { event: function (mouseEvent) { THIS.clickRightOrDown(mouseEvent); } }\n        }));\n        this.ishor = this.displaygroup.ishor;\n        this.displaycell = h(this.ishor, // note even though I'm using H - id chooses here.\n        (this.ishor) ? this.leftArrow : this.upArrow, this.prePaddle, this.paddle, this.postPaddle, (this.ishor) ? this.rightArrow : this.downArrow, this.label);\n    }\n    clickLeftorUp(mouseEvent, noTimes = 1) {\n        this.offset -= this.offsetPixelRatio * noTimes;\n        if (this.offset < 0)\n            this.offset = 0;\n        Handler.update();\n    }\n    clickRightOrDown(mouseEvent, noTimes = 1) {\n        this.offset += this.offsetPixelRatio * noTimes;\n        if (this.offset > this.maxOffset)\n            this.offset = this.maxOffset;\n        Handler.update();\n    }\n    clickPageLeftorUp(mouseEvent) {\n        this.offset -= this.displayedFixedPx;\n        if (this.offset < 0)\n            this.offset = 0;\n        Handler.update();\n    }\n    clickPageRightOrDown(mouseEvent) {\n        this.offset += this.displayedFixedPx;\n        if (this.offset > this.maxOffset)\n            this.offset = this.maxOffset;\n        Handler.update();\n    }\n    dragging(output) {\n        let diff = (this.ishor) ? output[\"x\"] : output[\"y\"];\n        // console.log(diff, diff*this.offsetPixelRatio);\n        let newoffset = this.offsetAtDrag + diff * this.offsetPixelRatio;\n        if (newoffset < 0)\n            newoffset = 0;\n        if (newoffset > this.maxOffset)\n            newoffset = this.maxOffset;\n        this.offset = newoffset;\n        Handler.update();\n    }\n    render(displaycell, parentDisplaygroup, index, derender) {\n        // console.log(this.label);\n        // console.log(this);\n        if (!this.parentDisplaygroup)\n            this.parentDisplaygroup = parentDisplaygroup;\n        let dgCoord = this.displaygroup.coord;\n        // calculate outer scrollbar dimensions\n        let x = (this.ishor) ? dgCoord.within.x : dgCoord.within.x + dgCoord.within.width - this.scrollWidth;\n        let width = (this.ishor) ? dgCoord.within.width : this.scrollWidth;\n        let y = (this.ishor) ? dgCoord.within.y + dgCoord.within.height - this.scrollWidth : dgCoord.within.y;\n        let height = (this.ishor) ? this.scrollWidth : dgCoord.within.height;\n        // let x = (this.ishor) ? dgCoord.x : dgCoord.x + dgCoord.width - this.scrollWidth;\n        // let width = (this.ishor) ? dgCoord.width : this.scrollWidth;\n        // let y = (this.ishor) ? dgCoord.y + dgCoord.height - this.scrollWidth : dgCoord.y;\n        // let height = (this.ishor) ? this.scrollWidth : dgCoord.height;\n        this.displaycell.coord.assign(x, y, width, height);\n        // calculate inner scrollbar dimensions\n        let preDisplayCell = this.displaycell.displaygroup.cellArray[1];\n        let paddleDisplayCell = this.displaycell.displaygroup.cellArray[2];\n        let postDisplayCell = this.displaycell.displaygroup.cellArray[3];\n        let actualFixedPx = this.displaygroup.totalPx();\n        let displayedFixedPx = this.displayedFixedPx = ((this.ishor) ? width : height);\n        this.maxOffset = actualFixedPx - displayedFixedPx;\n        if (this.offset > this.maxOffset)\n            this.offset = this.maxOffset;\n        if (this.offset < 0)\n            this.offset = 0;\n        // console.log(this.offset);\n        this.offsetPixelRatio = actualFixedPx / displayedFixedPx;\n        let prePercent = Math.round((this.offset / actualFixedPx) * 100);\n        let paddlePercent = Math.round((displayedFixedPx / actualFixedPx) * 100);\n        let postPercent = 100 - paddlePercent - prePercent;\n        preDisplayCell.dim = `${prePercent}%`;\n        paddleDisplayCell.dim = `${paddlePercent}%`;\n        postDisplayCell.dim = `${postPercent}%`;\n        Handler.currentZindex += Handler.zindexIncrement * 2;\n        this.currentlyRendered = !derender;\n        // console.log(this.displaycell);\n        Handler.renderDisplayCell(this.displaycell, undefined, undefined, derender);\n        Handler.currentZindex -= Handler.zindexIncrement * 2;\n    }\n    static distOfMouseFromWheel(THIS, event) {\n        let ishor = THIS.displaygroup.ishor;\n        let displaycell = THIS.displaycell;\n        let coord = displaycell.coord;\n        let x = event.clientX;\n        let y = event.clientY;\n        let dist = 0;\n        // console.log(ishor, x, y, coord)\n        if (!ishor) {\n            if (x < coord.x)\n                dist = coord.x - x;\n            if (x > coord.x + coord.width)\n                dist = x - (coord.x + coord.width);\n        }\n        else {\n            if (y < coord.y)\n                dist = coord.y - y;\n            if (y > coord.y + coord.height)\n                dist = y - (coord.y + coord.height);\n        }\n        return dist;\n    }\n    static onWheel(event) {\n        let selectedInstance;\n        let minDist = 100000;\n        let dist;\n        for (let instance of ScrollBar.instances) {\n            if (instance.currentlyRendered) {\n                if (instance.parentDisplaygroup.coord.isPointIn(event.clientX, event.clientY)\n                    || instance.displaycell.coord.isPointIn(event.clientX, event.clientY)) {\n                    dist = ScrollBar.distOfMouseFromWheel(instance, event);\n                    if (!selectedInstance || dist < minDist) {\n                        minDist = dist;\n                        selectedInstance = instance;\n                    }\n                }\n            }\n        }\n        if (selectedInstance) {\n            if (event.deltaY > 0)\n                selectedInstance.clickRightOrDown(event, ScrollBar.scrollWheelMult * event.deltaY / 100);\n            if (event.deltaY < 0)\n                selectedInstance.clickLeftorUp(event, -ScrollBar.scrollWheelMult * event.deltaY / 100);\n        }\n    }\n}\nScrollBar.instances = [];\nScrollBar.activeInstances = [];\nScrollBar.whiteBG = css(\"whiteBG\", \"background-color:white;outline: 1px solid black;outline-offset: -1px;\");\nScrollBar.blackBG = css(\"blackBG\", \"background-color:black;color:white;cursor: -webkit-grab; cursor: grab;\");\nScrollBar.defaults = {\n    offset: 0, displayAtEnd: true, scrollWidth: 15, currentlyRendered: true, arrowOffset: 2,\n};\nScrollBar.argMap = {\n    string: [\"label\"],\n    DisplayGroup: [\"displaygroup\"],\n    number: [\"fixedPixels\", \"viewingPixels\", \"scroolWidth\"],\n    boolean: [\"displayAtEnd\"]\n};\nScrollBar.scrollWheelMult = 4;\nScrollBar.triggerDistance = 40;\nOverlay.classes[\"ScrollBar\"] = ScrollBar;\n// export {ScrollBar}\n// import {/*BaseF,*/ Base} from './Base';\n// import {/*Point, Within,*/ Coord} from './Coord';\n// import {Css, css} from './Css';\n// import {DisplayCell, I} from './DisplayCell';\n// import {/*DisplayGroup, h,*/ v} from './DisplayGroup';\n// import {events, Events} from './Events';\n// import {Handler, H} from './Handler';\nclass Context extends Base {\n    constructor(...Arguments) {\n        super();\n        this.coord = new Coord();\n        this.buildBase(...Arguments);\n        if (!this.menuObj)\n            this.menuObj = Context.defaultObj;\n        this.height = Object.keys(this.menuObj).length * this.cellheight;\n        Context.makeLabel(this);\n        this.buildCell();\n    }\n    buildCell() {\n        let THIS = this;\n        let cellArray = [];\n        let numKeys = Object.keys(this.menuObj).length;\n        let index = 0;\n        let newContext;\n        this.displaycell = v({ cellArray: [ /* filled at bottom */] });\n        for (let key in this.menuObj) {\n            let valueFunctionOrObject = this.menuObj[key];\n            if (typeof (valueFunctionOrObject) == \"function\") {\n                cellArray.push(I(((index == numKeys - 1) ? \"100%\" : `${this.cellheight}px`), { innerHTML: key }, this.css, events({ onclick: function (mouseEvent) {\n                        valueFunctionOrObject(mouseEvent);\n                        THIS.popAll();\n                    } })));\n            }\n            else {\n                newContext = new Context({ menuObj: valueFunctionOrObject,\n                    width: this.width,\n                    cellheight: this.cellheight,\n                    css: this.css,\n                    parentContext: this\n                });\n                newContext.launchcell = I(((index == numKeys - 1) ? \"100%\" : `${this.cellheight}px`), { innerHTML: key }, this.css, events({ onmouseover: function () {\n                        let coord = THIS.coord;\n                        if (!newContext.handler)\n                            newContext.render(undefined, coord.x + coord.width - Context.subOverlapPx, coord.y + THIS.cellheight * (index - 2) - Context.subOverlapPx);\n                    }\n                }));\n                cellArray.push(newContext.launchcell);\n            }\n            index += 1;\n        }\n        this.displaycell.displaygroup.cellArray = cellArray;\n    }\n    popAll() {\n        this.pop();\n        if (this.parentContext)\n            this.parentContext.popAll();\n        else\n            window.onmousemove = function () { };\n    }\n    pop() {\n        this.handler.pop();\n        this.handler = undefined;\n        if (this.parentContext)\n            Context.lastRendered = this.parentContext;\n    }\n    managePop(mouseEvent) {\n        let x = mouseEvent.clientX;\n        let y = mouseEvent.clientY;\n        let pop = !this.displaycell.coord.isPointIn(x, y);\n        if (pop && this.launchcell && this.launchcell.coord.isPointIn(x, y))\n            pop = false;\n        let THIS = this;\n        if (pop) {\n            if (this.parentContext)\n                window.onmousemove = function (mouseEvent) { THIS.parentContext.managePop(mouseEvent); };\n            else\n                window.onmousemove = function () { };\n            this.pop();\n        }\n    }\n    render(mouseEvent, x = 0, y = 0) {\n        if (mouseEvent) {\n            x = mouseEvent.clientX - Context.subOverlapPx;\n            y = mouseEvent.clientY - Context.subOverlapPx;\n        }\n        this.coord.assign(x, y, this.width, this.height);\n        this.handler = H(this.displaycell, this.coord);\n        let THIS = this;\n        window.onmousemove = function (mouseEvent) { THIS.managePop(mouseEvent); };\n        Context.lastRendered = this;\n    }\n    hMenuBarx() { return this.launchcell.coord.x; }\n    hMenuBary() { return this.launchcell.coord.y + this.launchcell.coord.height; }\n    vMenuBarx() { return this.launchcell.coord.x + this.launchcell.coord.width; }\n    vMenuBary() { return this.launchcell.coord.y; }\n}\nContext.subOverlapPx = 4;\nContext.instances = [];\nContext.activeInstances = [];\nContext.defaultMenuBarCss = css(\"menuBar\", \"background-color:white;color: black;\");\nContext.defaultMenuBarHover = css(\"menuBar:hover\", \"background-color:black;color: white;\");\nContext.defaultMenuBarNoHoverCss = css(\"menuBarNoHover\", \"background-color:white;color: black;\");\nContext.defaultObj = { one: function () { console.log(\"one\"); },\n    two: function () { console.log(\"two\"); },\n    three: function () { console.log(\"three\"); },\n};\nContext.defaults = {\n    width: 100,\n    cellheight: 25,\n    css: Css.theme.context, //Context.defaultContextCss\n};\nContext.argMap = {\n    string: [\"label\"],\n    number: [\"width\", \"cellheight\"]\n};\nlet context = function (...Arguments) {\n    let newcontext = new Context(...Arguments);\n    return function (mouseEvent) { newcontext.render(mouseEvent); return false; };\n};\nlet hMenuBar = function (...Arguments) {\n    let newcontext = new Context(...Arguments);\n    return function (mouseEvent) {\n        if (Context.lastRendered && Context.lastRendered.handler) {\n            Context.lastRendered.popAll();\n        }\n        newcontext.render(undefined, newcontext.hMenuBarx(), newcontext.hMenuBary());\n        return false;\n    };\n};\nlet vMenuBar = function (...Arguments) {\n    let newcontext = new Context(...Arguments);\n    return function (mouseEvent) { newcontext.render(undefined, newcontext.vMenuBarx(), newcontext.vMenuBary()); return false; };\n};\n// export {vMenuBar, hMenuBar, context, Context}\n// import {Base} from './Base';\n// import {Css, css} from './Css';\n// import {DisplayCell, I} from './DisplayCell';\n// import {Handler, H} from './Handler';\n// import {Coord} from './Coord';\n// import {DisplayGroup, v, h} from './DisplayGroup';\n// import {events, Events} from './Events';\n// import {Overlay} from './Overlay';\n// import {mf, pf} from './PureFunctions';\nclass Modal extends Base {\n    constructor(...Arguments) {\n        super();\n        this.buildBase(...Arguments);\n        if (\"number\" in this.retArgs) {\n            this.setSize(...this.retArgs[\"number\"]);\n        }\n        if (!this.coord) {\n            let [vpX, vpY] = pf.viewport();\n            this.coord = new Coord(Math.round(vpX / 4), Math.round(vpY / 4), Math.round(vpX / 2), Math.round(vpY / 2));\n            this.coord.within.x = this.coord.within.y = 0;\n            this.coord.within.width = vpX;\n            this.coord.within.height = vpY;\n        }\n        if (!this.withinCoord) {\n            this.withinCoord = (Handler.activeInstances.length) ? Handler.activeInstances[0].rootCell.coord\n                : Handler.screenSizeCoord;\n        }\n        if (!this.fullCell) {\n            if (!this.bodyCell) {\n                this.bodyCell = I(this.label, this.innerHTML, Modal.bodyCss);\n            }\n            if (this.footerTitle) {\n                this.showFooter = true;\n            }\n            Modal.makeLabel(this); // see Base.ts\n            this.build();\n        }\n        this.handler = H(`${this.label}_h`, v(this.fullCell), this.coord, false, this.preRenderCallback.bind(this));\n    }\n    setSize(...numbers) {\n        let [vpX, vpY] = pf.viewport();\n        let numberOfArgs = numbers.length;\n        let x, y, width, height;\n        if (numberOfArgs >= 2 && numberOfArgs < 4) {\n            if (!this.coord)\n                this.coord = new Coord();\n            width = numbers[0];\n            height = numbers[1];\n            x = (vpX - width) / 2;\n            y = (vpY - height) / 2;\n            this.coord.assign(x, y, width, height);\n        }\n        else if (numberOfArgs >= 4) {\n            if (!this.coord)\n                this.coord = new Coord();\n            this.coord.assign(numbers[0], numbers[1], numbers[2], numbers[3]);\n            this.coord.within.x = this.coord.within.y = 0;\n            this.coord.within.width = vpX;\n            this.coord.within.height = vpY;\n        }\n    }\n    setContent(html) { this.bodyCell.htmlBlock.innerHTML = html; Handler.update(); }\n    setTitle(html) { this.headerCell.displaygroup.cellArray[0].htmlBlock.innerHTML = html; Handler.update(); }\n    setFooter(html) { this.footerCell.displaygroup.cellArray[0].htmlBlock.innerHTML = html; Handler.update(); }\n    buildClose() {\n        let THIS = this;\n        return I({ innerHTML: `<svg viewPort=\"0 0 ${this.headerHeight} ${this.headerHeight}\" version=\"1.1\"\r\n        xmlns=\"http://www.w3.org/2000/svg\" style=\"width: ${this.headerHeight}px; height: ${this.headerHeight}px;\">\r\n        <line x1=\"3\" y1=\"${this.headerHeight - 3}\" x2=\"${this.headerHeight - 3}\" y2=\"3\" \r\n          stroke=\"black\" stroke-width=\"2\"/>\r\n        <line x1=\"3\" y1=\"3\" x2=\"${this.headerHeight - 3}\" y2=\"${this.headerHeight - 3}\" \r\n          stroke=\"black\" stroke-width=\"2\"/></svg>`\n        }, Modal.closeCss, `${this.headerHeight}px`, events({ onclick: function () { THIS.hide(); } }));\n    }\n    buildHeader() {\n        let THIS = this;\n        if (!this.headerCell) {\n            this.headerCell = h(`${this.label}_header`, `${this.headerHeight}px`, I(`${this.label}_headerTitle`, this.headerTitle, Modal.headerCss, events({ ondrag: { onDown: function () { Modal.movingInstace = THIS; return Modal.startMoveModal(THIS.handler); }, onMove: function (offset) { return Modal.moveModal(THIS.handler, offset); },\n                    onUp: function (offset) { Modal.movingInstace = undefined; }\n                } })));\n            if (this.showClose) {\n                this.headerCell.displaygroup.cellArray.push(this.buildClose());\n            }\n        }\n    }\n    buildFooter() {\n        if (!this.footerCell)\n            this.footerCell = h(`${this.label}_footer`, `${this.footerHeight}px`, I(`${this.label}_footerTitle`, this.footerTitle, Modal.footerCss));\n    }\n    buildOptions() {\n        let THIS = this;\n        if (!this.optionsCell)\n            this.optionsCell = h(`${this.label}_options`, `${this.optionsHeight}px`, I(`${this.label}_okButton`, `<button>OK</button>`, Modal.optionsCss, events({ onclick: function () { THIS.hide(); } })));\n    }\n    buildFull() {\n        this.fullCell = v(this.bodyCell);\n        if (this.showHeader) {\n            this.fullCell.displaygroup.cellArray.unshift(this.headerCell);\n        }\n        if (this.showOptions) {\n            this.fullCell.displaygroup.cellArray.push(this.optionsCell);\n        }\n        if (this.showFooter) {\n            this.fullCell.displaygroup.cellArray.push(this.footerCell);\n        }\n    }\n    build() {\n        this.buildHeader();\n        this.buildFooter();\n        this.buildOptions();\n        this.buildFull();\n    }\n    show() {\n        Handler.activate(this.handler);\n        Handler.update();\n    }\n    hide() {\n        this.handler.pop();\n    }\n    preRenderCallback(handler) {\n        let within = this.withinCoord.within;\n        let x = within.x, y = within.y, x2 = within.x + within.width, y2 = within.y + within.height;\n        let coord = handler.coord;\n        if (coord.x + coord.width > x2)\n            coord.x = x2 - coord.width; // something\n        if (coord.x < x) {\n            coord.width += coord.x;\n            coord.x = x;\n        } // is off here - make outer margin huge to see!\n        if (coord.y + coord.height > y2)\n            coord.y = y2 - coord.height;\n        if (coord.y < y) {\n            coord.height += coord.y;\n            coord.y = y;\n        }\n    }\n    static startMoveModal(handler) {\n        handler.toTop();\n        Modal.x = handler.coord.x;\n        Modal.y = handler.coord.y;\n    }\n    static moveModal(handler, offset) {\n        Modal.offset = offset;\n        let vp = pf.viewport();\n        let x = Modal.x + offset[\"x\"];\n        if (x < 0)\n            x = 0;\n        if (x + handler.coord.width > vp[0])\n            x = vp[0] - handler.coord.width;\n        handler.coord.x = x;\n        let y = Modal.y + offset[\"y\"];\n        if (y < 0)\n            y = 0;\n        if (y + handler.coord.height > vp[1])\n            y = vp[1] - handler.coord.height;\n        handler.coord.y = y;\n        Handler.update();\n    }\n}\nModal.instances = [];\nModal.activeInstances = [];\nModal.headerCss = css(\"HeaderTitle\", \"background-color:blue;color:white;text-align: center;border: 1px solid black;cursor: -webkit-grab; cursor: grab;\");\nModal.footerCss = css(\"FooterTitle\", \"background-color:white;color:black;border: 1px solid black;\");\nModal.closeCss = css(\"Close\", \"background-color:white;color:black;border: 1px solid black;font-size: 20px;\");\nModal.closeCssHover = css(\"Close:hover\", \"background-color:red;color:white;border: 1px solid black;font-size: 20px;\");\nModal.bodyCss = css(\"ModalBody\", \"background-color:white;border: 1px solid black;\");\nModal.optionsCss = css(\"ModalOptions\", \"background-color:white;border: 1px solid black;display: flex;justify-content: center;align-items: center;\");\nModal.defaults = {\n    showHeader: true, showFooter: false, resizeable: true, showClose: true, showOptions: true,\n    headerHeight: 20, footerHeight: 20, headerTitle: \"\", footerTitle: \"\", innerHTML: \"\", optionsHeight: 30,\n};\nModal.argMap = {\n    string: [\"label\", \"innerHTML\", \"headerTitle\", \"footerTitle\"],\n    DisplayCell: [\"bodyCell\", \"optionsCell\", \"footerCell\", \"headerCell\"],\n    Coord: [\"coord\", \"withinCoord\"]\n};\nclass Stretch extends Base {\n    constructor(...Arguments) {\n        super();\n        this.buildBase(...Arguments);\n        if (!this.parentDisplaycell && this.parentModal)\n            this.parentDisplaycell = this.parentModal.fullCell;\n        this.UL = I(`${this.label}_UL`, Stretch.NWcss, this.events(\"UL\"));\n        this.UR = I(`${this.label}_UR`, Stretch.NEcss, this.events(\"UR\"));\n        this.LL = I(`${this.label}_LL`, Stretch.NEcss, this.events(\"LL\"));\n        this.LR = I(`${this.label}_LR`, Stretch.NWcss, this.events(\"LR\"));\n        Stretch.makeLabel(this);\n    }\n    events(corner) {\n        let THIS = this;\n        return events({ ondrag: { onDown: function (mouseDiff) {\n                    let coord = (THIS.parentModal) ? THIS.parentModal.handler.coord : THIS.parentDisplaycell.coord;\n                    Stretch.startCoord.copy(coord);\n                    Stretch.corner = corner;\n                }, onMove: function (diff) {\n                    let [vpX, vpY] = pf.viewport();\n                    let coord = (THIS.parentModal) ? THIS.parentModal.handler.coord : THIS.parentDisplaycell.coord;\n                    let ssc = Stretch.startCoord;\n                    let x, y, width, height;\n                    switch (Stretch.corner) {\n                        case \"UL\":\n                            width = ssc.width - diff.x;\n                            if (width < THIS.minWidth) {\n                                diff.x -= (THIS.minWidth - width);\n                                width = THIS.minWidth;\n                            }\n                            height = ssc.height - diff.y;\n                            if (height < THIS.minHeight) {\n                                diff.y -= (THIS.minHeight - height);\n                                height = THIS.minHeight;\n                            }\n                            x = ssc.x + diff.x;\n                            if (x < 0) {\n                                width += x;\n                                x = 0;\n                            }\n                            y = ssc.y + diff.y;\n                            if (y < 0) {\n                                height += y;\n                                y = 0;\n                            }\n                            break;\n                        case \"UR\":\n                            x = ssc.x;\n                            width = ssc.width + diff.x;\n                            if (width < THIS.minWidth) {\n                                diff.x -= (THIS.minWidth - width);\n                                width = THIS.minWidth;\n                            }\n                            if (x + width > vpX) {\n                                width += (vpX - (x + width));\n                            }\n                            height = ssc.height - diff.y;\n                            if (height < THIS.minHeight) {\n                                diff.y -= (THIS.minHeight - height);\n                                height = THIS.minHeight;\n                            }\n                            y = ssc.y + diff.y;\n                            if (y < 0) {\n                                height += y;\n                                y = 0;\n                            }\n                            break;\n                        case \"LL\":\n                            width = ssc.width - diff.x;\n                            if (width < THIS.minWidth) {\n                                diff.x -= (THIS.minWidth - width);\n                                width = THIS.minWidth;\n                            }\n                            x = ssc.x + diff.x;\n                            if (x < 0) {\n                                width += x;\n                                x = 0;\n                            }\n                            y = ssc.y;\n                            height = ssc.height + diff.y;\n                            if (height < THIS.minHeight) {\n                                diff.y -= (THIS.minHeight - height);\n                                height = THIS.minHeight;\n                            }\n                            if (height + y > vpY) {\n                                height = vpY - y;\n                            }\n                            break;\n                        case \"LR\":\n                            x = ssc.x;\n                            y = ssc.y;\n                            width = ssc.width + diff.x;\n                            if (width < THIS.minWidth)\n                                width = THIS.maxWidth;\n                            if (width + x > vpX)\n                                width = vpX - x;\n                            height = ssc.height + diff.y;\n                            if (height < THIS.minHeight)\n                                height = THIS.maxHeight;\n                            if (height + y > vpY)\n                                height = vpY - y;\n                            break;\n                        default:\n                            break;\n                    }\n                    coord.assign(x, y, width, height);\n                    Handler.update();\n                }, onUp: this.onUpCallBack } });\n    }\n    ;\n    render(displaycell, parentDisplaygroup, index, derender) {\n        if (!derender) {\n            let coord = this.parentDisplaycell.coord;\n            this.UL.coord.assign(coord.x, coord.y, this.pxSize, this.pxSize, coord.within.x, coord.within.y, coord.within.width, coord.within.height, coord.zindex + Handler.zindexIncrement);\n            this.UR.coord.assign(coord.x + coord.width - this.pxSize + 1, coord.y, this.pxSize, this.pxSize, coord.within.x, coord.within.y, coord.within.width, coord.within.height, coord.zindex + Handler.zindexIncrement);\n            this.LL.coord.assign(coord.x, coord.y + coord.height - this.pxSize + 1, this.pxSize, this.pxSize, coord.within.x, coord.within.y, coord.within.width, coord.within.height, coord.zindex + Handler.zindexIncrement);\n            this.LR.coord.assign(coord.x + coord.width - this.pxSize + 1, coord.y + coord.height - this.pxSize + 1, this.pxSize, this.pxSize, coord.within.x, coord.within.y, coord.within.width, coord.within.height, coord.zindex + Handler.zindexIncrement);\n        }\n        let array = [this.UL, this.UR, this.LL, this.LR];\n        for (let index = 0; index < array.length; index++)\n            Handler.renderDisplayCell(array[index], undefined, undefined, derender);\n    }\n}\nStretch.labelNo = 0;\nStretch.instances = [];\nStretch.activeInstances = [];\nStretch.defaults = {\n    pxSize: 10, minWidth: 200, minHeight: 200, onUpCallBack: function () { },\n};\nStretch.argMap = {\n    string: [\"label\"],\n    Modal: [\"parentModal\"],\n};\nStretch.NWcss = new Css(\"NWcss\", `cursor: nw-resize;`);\nStretch.NEcss = new Css(\"NEcss\", `cursor: ne-resize;`);\nStretch.startCoord = new Coord();\nfunction stretch(...Arguments) {\n    let overlay = new Overlay(\"Stretch\", ...Arguments);\n    let newStretch = overlay.returnObj;\n    let parentDisplaycell = newStretch.parentDisplaycell;\n    parentDisplaycell.addOverlay(overlay);\n    return (newStretch.parentModal) ? newStretch.parentModal : parentDisplaycell;\n}\nOverlay.classes[\"Stretch\"] = Stretch;\n// export {Modal, stretch}\n// events({ondrag: {onDown :function(xmouseDiff:object){\n//     if (pf.isTypePercent(dragbar.parentDisplaycell.dim)) {\n//         dragbar.parentDisplaygroup.percentToPx(dragbar.parentDisplaycell);\n//     }\n//     dragbar.startpos = pf.pxAsNumber(dragbar.parentDisplaycell.dim);\n// },\n// onMove :function(xmouseDiff:object){\n//     let newdim = dragbar.startpos + ((dragbar.ishor) ? xmouseDiff[\"x\"]: xmouseDiff[\"y\"])*((dragbar.isLast) ? -1 :1);\n//     if (newdim > dragbar.max) newdim = dragbar.max;\n//     if (newdim < dragbar.min) newdim = dragbar.min;\n//     dragbar.parentDisplaycell.dim = `${newdim}px`;\n//     Handler.update();\n// },\n// // onUp: function(ouxmouseDifftput:object){}\n// } })\n// import {Base} from './Base';\n// import {DisplayCell, I} from './DisplayCell';\n// import {Coord} from './Coord';\n// import {events, Events} from './Events';\n// import {Css, css} from './Css';\n// import {DisplayGroup, h, v} from './DisplayGroup';\n// import {Handler} from './Handler';\n// import {Drag} from './Drag';\n// import {Pages, P} from './Pages';\n// import {HtmlBlock} from './htmlBlock';\n// import {Overlay} from './Overlay';\n// import {pf} from './PureFunctions';\nclass TreeNode extends Base {\n    constructor(...Arguments) {\n        super();\n        this.collapsed = false;\n        this.nodeCellArray = [];\n        this.buildBase(...Arguments);\n        if (this.labelCell.htmlBlock)\n            this.labelCell.htmlBlock.hideWidth = this.labelCell.coord.hideWidth = true;\n        if (this.labelCell && !this.label)\n            this.label = this.labelCell.label;\n    }\n    visibleChildren(noChildren = 0) {\n        if (!this.collapsed && this.children)\n            for (let child of this.children)\n                noChildren += child.visibleChildren(1);\n        return noChildren;\n    }\n    addDisplayCells(newCellArray = [], isFirst = true) {\n        if (!isFirst)\n            newCellArray.push(this.horizontalDisplayCell);\n        if (!this.collapsed && this.children) {\n            for (let childNode of this.children) {\n                newCellArray = childNode.addDisplayCells(newCellArray, false);\n            }\n        }\n        return newCellArray;\n    }\n}\nTreeNode.instances = [];\nTreeNode.activeInstances = [];\nTreeNode.defaults = {};\nTreeNode.argMap = {\n    DisplayCell: [\"labelCell\"],\n    string: [\"label\"],\n    Array: [\"children\"],\n    boolean: [\"collapsed\"]\n};\nfunction T(...Arguments) { return new TreeNode(...Arguments); }\nclass Tree extends Base {\n    constructor(...Arguments) {\n        super();\n        this.css = \"\"; // default class(es) for tree items.\n        this.buildBase(...Arguments);\n        if (!this.parentDisplayCell) {\n            this.parentDisplayCell = new DisplayCell(`TreeRoot_${this.label}`);\n        }\n        if (\"Css\" in this.retArgs) // duplicated!!!!!\n            for (let css of this.retArgs[\"Css\"])\n                this.css = (this.css + \" \" + css.classname).trim();\n        if (\"string\" in this.retArgs && this.retArgs.string.length > 1)\n            this.css += \" \" + this.retArgs.string.splice(1).join(' ');\n        // console.log(this.parentDisplayCell)\n        let V = v(`${this.label}_rootV`, this.parentDisplayCell.dim, this.margin, this.margin); ////////////////////////////////////// check this again!\n        let cellArray = V.displaygroup.cellArray;\n        this.parentDisplayCell.displaygroup = new DisplayGroup(`${this.label}_rootH`, V);\n        if (this.t_instance && !this.rootTreeNode) {\n            // console.log(\"Froud t_!\");\n            this.rootTreeNode = Tree.autoLabelTreenodes(this.label, this.t_instance);\n        }\n        if (!this.rootTreeNode) {\n            this.rootTreeNode = Tree.defaultObj;\n        }\n        this.parentDisplayCell.preRenderCallback = function (displaycell, parentDisplaygroup /*= undefined*/, index /*= undefined*/, derender) {\n            if (!Handler.firstRun) {\n                let bounding;\n                let max = 0;\n                let x2;\n                let elements = document.querySelectorAll(\"[treenode]\");\n                for (let element of elements) {\n                    bounding = element.getBoundingClientRect();\n                    x2 = bounding[\"x\"] + bounding[\"width\"];\n                    if (x2 > max)\n                        max = x2;\n                }\n                let current = displaycell.coord.x + displaycell.coord.width;\n                let dx = displaycell.coord.x;\n                displaycell.displaygroup.cellArray[0].dim = `${(current > max) ? current - dx : max - dx}px`;\n                // displaycell.displaygroup.cellArray[0].dim = `${(current > max) ? current-2 : max}px`;  ///// BINGO!!!!!!!!!\n                // console.log(displaycell.label, displaycell.coord);\n                // console.log(displaycell.displaygroup.cellArray[0].dim)\n            }\n        };\n        Tree.makeLabel(this);\n        this.buildTreeNode(this.rootTreeNode, cellArray);\n    }\n    // autoLabel(node = this.rootTreeNode, newLabel=`${this.label}`){\n    //     // node.label = node.labelCell.label = node.labelCell.htmlBlock.label = newLabel;\n    //     node.label = newLabel;\n    //     if (node.labelCell) {\n    //         node.labelCell.label = newLabel;\n    //         if (node.labelCell.htmlBlock)\n    //             node.labelCell.htmlBlock.label = newLabel;\n    //     }\n    //     for (const key in node.children)\n    //         this.autoLabel(node.children[key], `${newLabel}_${key}`);\n    // }\n    drawSVG(collapsed) {\n        let X = this.collapsePad;\n        let Y = (this.cellHeight - this.collapseSize) / 2 + this.collapsePad;\n        let XX = this.collapseSize - X;\n        let YY = Y + this.collapseSize - 2 * this.collapsePad;\n        let XMID = this.collapseSize / 2;\n        let YMID = this.cellHeight / 2;\n        let C = this.SVGColor;\n        return `<svg height=\"${this.cellHeight}\" width=\"${this.collapseSize}\">` +\n            ((collapsed) ? `<polygon points=\"${X},${Y} ${XX},${YMID} ${X},${YY} ${X},${Y}\"`\n                : `<polygon points=\"${X},${Y} ${XX},${Y} ${XMID},${YY} ${X},${Y}\"`) +\n            `style=\"fill:${C};stroke:${C};stroke-width:1\" />\r\n            </svg>`;\n    }\n    toggleCollapse(node, mouseEvent, el) {\n        node.collapsed = !node.collapsed;\n        node.horizontalDisplayCell.displaygroup.cellArray[1].htmlBlock.innerHTML = this.drawSVG(node.collapsed);\n        let cellArray = this.parentDisplayCell.displaygroup.cellArray[0].displaygroup.cellArray;\n        let index = cellArray.indexOf(node.horizontalDisplayCell);\n        // remove from Dom if collapsed\n        if (node.collapsed) {\n            for (let displaycell of node.nodeCellArray) {\n                Handler.renderDisplayCell(displaycell, undefined, undefined, true);\n            }\n            node.collapsed = !node.collapsed;\n            let noVisibleChildren = node.visibleChildren();\n            node.collapsed = !node.collapsed;\n            cellArray.splice(index + 1, noVisibleChildren);\n        }\n        else { // Add DisplayCells if Toggled Open\n            cellArray.splice(index + 1, 0, ...node.addDisplayCells());\n        }\n        Handler.update();\n    }\n    buildTreeNode(node = this.rootTreeNode, cellArray, indent = this.startIndent) {\n        let THIS = this;\n        let hasChildren = (node.children) ? ((node.children.length) ? true : false) : false;\n        node.labelCell.htmlBlock.attributes[\"treenode\"] = \"\";\n        if (!node.labelCell.htmlBlock.css && this.css.trim())\n            node.labelCell.htmlBlock.css = this.css.trim();\n        if (!node.labelCell.htmlBlock.events && this.events)\n            node.labelCell.htmlBlock.events = this.events;\n        node.horizontalDisplayCell = h(// Horizontal DisplayGroup Containing:\n        I(node.label + \"_spacer\", \"\", `${indent}px`), // spacer First\n        I(node.label + \"_svg\", // This is the SVG\n        (hasChildren) ? this.drawSVG(node.collapsed) : \"\", `${this.collapseSize}px`, events({ onclick: function (mouseEvent) {\n                mouseEvent.preventDefault();\n                THIS.toggleCollapse(node, mouseEvent, this);\n            },\n            onmousedown: function (mouseEvent) {\n                window.addEventListener('selectstart', Drag.disableSelect);\n            },\n            onmouseup: function (mouseEvent) {\n                window.removeEventListener('selectstart', Drag.disableSelect);\n            }\n        })), node.labelCell, // This is the TreeNode Label\n        `${this.cellHeight}px` // Height in pixels of TreeNode\n        );\n        cellArray.push(node.horizontalDisplayCell);\n        if (node.children) {\n            for (let childNode of node.children)\n                this.buildTreeNode(childNode, node.nodeCellArray, indent + this.indent);\n            if (!node.collapsed)\n                DisplayCell.concatArray(cellArray, node.nodeCellArray);\n        }\n    }\n    render(displaycell) { }\n    static autoLabelTreenodes(label, rootNode) {\n        Tree.autoLabel(rootNode, label);\n        // console.log(rootNode);\n        return Tree.makeTreeNodes(rootNode);\n    }\n    static autoLabel(tObj, postfix /*=\"autoTree\"*/) {\n        tObj.label = postfix;\n        (tObj.TreeNodeArguments[0]).label = postfix;\n        if (tObj.TreeNodeArguments.length > 1) {\n            let ta = (tObj.TreeNodeArguments[1]);\n            for (let index = 0; index < ta.length; index++) {\n                const t = ta[index];\n                Tree.autoLabel(t, postfix + \"_\" + index);\n            }\n        }\n    }\n    static makeTreeNodes(node) {\n        let arrayOft_;\n        let returnArray = [];\n        let returnTreeNode;\n        let ii = node.TreeNodeArguments[0];\n        if (node.TreeNodeArguments.length > 1) {\n            arrayOft_ = node.TreeNodeArguments[1];\n            for (const singlet_ of arrayOft_) {\n                returnArray.push(Tree.makeTreeNodes(singlet_));\n            }\n            returnTreeNode = T(node.label, I(ii.label, ...ii.Arguments), returnArray);\n        }\n        else {\n            returnTreeNode = T(node.label, I(ii.label, ...ii.Arguments));\n        }\n        return returnTreeNode;\n    }\n    static t(...Arguments) { return new t_(...Arguments); }\n    static i(...Arguments) { return new i_(...Arguments); }\n    static onclick(event) {\n        let el = this; // this onclick function is called BOUND to element.\n        let value = el.getAttribute(\"pagebutton\");\n        let valueArray = value.split(\"|\");\n        let pagename = valueArray[0];\n        let pageNo = valueArray[1];\n        Pages.setPage(pagename, parseInt(pageNo));\n        if (HtmlBlock.byLabel(el.id).events && HtmlBlock.byLabel(el.id).events.actions[\"onclick\"]) {\n            var doit = HtmlBlock.byLabel(el.id).events.actions[\"onclick\"].bind(el);\n            doit(event);\n        }\n    }\n}\nTree.instances = [];\nTree.activeInstances = [];\nTree.defaultObj = T(\"Tree\", I(\"Tree_TopDisplay\", \"Top Display\"), [T(\"Tree_child1\", I(\"Tree_Child1ofTop\", \"Child1ofTop\"), // true,       \n    [T(\"Tree_child1_1\", I(\"Tree_Child1ofChild1\", \"Child1ofChild1\")),\n        T(\"Tree_child1_2\", I(\"Tree_Child2ofChild1\", \"Child2ofChild1\"))\n    ]),\n    T(\"Tree_child2\", I(\"Tree_Child2ofTop\", \"Child2ofTop\"))]);\nTree.defaults = {\n    cellHeight: 20, SVGColor: \"white\", startIndent: 0, indent: 10, collapsePad: 4, collapseSize: 16,\n    margin: 2,\n};\nTree.argMap = {\n    string: [\"label\"],\n    number: [\"cellHeight\", \"margin\"],\n    TreeNode: [\"rootTreeNode\"],\n    DisplayCell: [\"parentDisplayCell\"],\n    Events: [\"events\"],\n    t_: [\"t_instance\"],\n};\nfunction tree(...Arguments) {\n    let overlay = new Overlay(\"Tree\", ...Arguments);\n    let newTree = overlay.returnObj;\n    let displaycell = newTree.parentDisplayCell;\n    // displaycell.overlay = overlay; // remove this one soon\n    displaycell.addOverlay(overlay);\n    return displaycell;\n}\nOverlay.classes[\"Tree\"] = Tree;\n// this is a messy way to solve a problem...\nfunction TI(...Arguments) {\n    let arg;\n    let arrayInArgs;\n    let newT;\n    for (let index = 0; index < Arguments.length; index++) { // pull array from Arguments\n        arg = Arguments[index];\n        if (pf.isArray(arg)) {\n            arrayInArgs = arg;\n            Arguments.splice(index, 1);\n            index -= 1;\n        }\n    }\n    let newI = Tree.i(/* \"auto\", */ ...Arguments); // name auto picked up in Tree Constructor.\n    if (arrayInArgs)\n        newT = Tree.t(newI, arrayInArgs);\n    else\n        newT = Tree.t(newI);\n    return newT;\n}\nclass i_ {\n    constructor(...Arguments) { this.Arguments = Arguments; }\n}\nclass t_ {\n    constructor(...Arguments) { this.TreeNodeArguments = Arguments; }\n}\n// export {t_, i_, TI, tree, TreeNode, Tree}\n// import {Base} from './Base';\n// import {DisplayCell} from './DisplayCell';\n// import {Handler} from './Handler';\n// import {Coord} from './Coord';\n// import {FunctionStack} from './FunctionStack';\n// import {DisplayGroup} from './DisplayGroup';\n// import {mf, pf} from './PureFunctions';\nclass Observe extends Base {\n    // derendering: boolean = false;\n    constructor(...Arguments) {\n        super();\n        this.buildBase(...Arguments);\n        let observerInstance = this;\n        let handler = Handler.byLabel(observerInstance.label);\n        if (!handler.coord)\n            handler.coord = new Coord();\n        // put handler in stack if not there already (push Handler)\n        if (Handler.activeInstances.indexOf(handler) == -1) {\n            Handler.activeInstances.push(handler);\n        }\n        this.parentDisplayCell.htmlBlock.el.onscroll = function (event) { Observe.onScroll(event); };\n        handler.controlledBySomething = true;\n        if (!this.parentDisplayCell.postRenderCallback)\n            this.parentDisplayCell.postRenderCallback = FunctionStack.function(this.parentDisplayCell.label);\n        Observe.makeLabel(this);\n        FunctionStack.push(this.parentDisplayCell.label, function (displaycell, parentDisplaygroup = undefined, index = undefined, derender = false) {\n            let el = displaycell.htmlBlock.el;\n            let dCoord = displaycell.coord;\n            let handler = Handler.byLabel(observerInstance.label);\n            let hCoord = handler.coord;\n            let bound = observerInstance.el.getBoundingClientRect();\n            hCoord.x = bound.x;\n            hCoord.y = bound.y;\n            hCoord.width = bound.width;\n            hCoord.height = bound.height;\n            hCoord.within.x = dCoord.x;\n            hCoord.within.y = dCoord.y;\n            hCoord.within.width = dCoord.width - ((el.scrollHeight > el.clientHeight) ? Observe.Os_ScrollbarSize : 0);\n            hCoord.within.height = dCoord.height - ((el.scrollWidth > el.clientWidth) ? Observe.Os_ScrollbarSize : 0);\n        });\n        Handler.update();\n    }\n    static derender(displaycell) {\n        let handler;\n        // \n        for (let index = 0; index < Observe.instances.length; index++) {\n            let observeInstance = Observe.instances[index];\n            if (observeInstance.parentDisplayCell == displaycell) {\n                handler = Handler.byLabel(observeInstance.label);\n                let Hindex = Handler.activeInstances.indexOf(handler);\n                if (Hindex > -1) {\n                    Handler.activeInstances.splice(Hindex, 1);\n                }\n                let Oindex = Observe.instances.indexOf(observeInstance);\n                Observe.instances.splice(Oindex, 1);\n                Handler.renderDisplayCell(handler.rootCell, undefined, undefined, true);\n                index -= 1;\n            }\n        }\n        FunctionStack.pop(displaycell.label);\n    }\n    static onScroll(event) {\n        for (let index = 0; index < Observe.instances.length; index++) {\n            const observeInstance = Observe.instances[index];\n            observeInstance.parentDisplayCell.postRenderCallback(observeInstance.parentDisplayCell);\n            Handler.update();\n        }\n    }\n    static update() {\n        let els = document.querySelectorAll(\"[parentof]\");\n        let activeLabels = [];\n        for (let index = 0; index < els.length; index++) { // loop elements in dom with parentof attribute...\n            let el = els[index];\n            let attribObj = pf.getAttribs(el);\n            let handlerLabel = attribObj[\"parentof\"];\n            let handlerInstance = Handler.byLabel(handlerLabel);\n            if (handlerInstance) { // if matching handler exists,\n                activeLabels.push(handlerLabel);\n                if (!Observe.byLabel(handlerLabel)) { // if not matching Observe instance exists\n                    let parentEl = el.parentElement;\n                    let parentDisplayCell;\n                    while (parentEl && !parentDisplayCell) { // loop until parent matching displaycell found\n                        parentDisplayCell = DisplayCell.byLabel(parentEl.id);\n                        parentEl = parentEl.parentElement;\n                    }\n                    new Observe(handlerLabel, el, parentDisplayCell); // Create Observe Object!\n                }\n            } // else console.log(`Handler \"${handlerLabel}\" not found`);\n        }\n        // for (let index = 0; index < Observe.instances.length; index++) {  // now pop any Observers no longer needed\n        //     const observeInstance = Observe.instances[index];\n        //     if (activeLabels.indexOf(observeInstance.label) == -1) {\n        //         observeInstance.pop();\n        //     }\n        // }\n    }\n}\nObserve.instances = [];\nObserve.activeInstances = [];\nObserve.defaults = {};\nObserve.argMap = {\n    string: [\"label\"],\n    HTMLDivElement: [\"el\"],\n    DisplayCell: [\"parentDisplayCell\"],\n};\nObserve.Os_ScrollbarSize = 15;\n// export {Observe}\n// import {Base} from './Base';\n// import {DisplayCell, I} from './DisplayCell';\n// import {DisplayGroup, v, h} from './DisplayGroup';\n// import {Coord} from './Coord';\n// import {Handler} from './Handler';\n// import {Overlay} from './Overlay';\n// import {css, Css} from './Css';\n// import {Modal} from './Modal';\n// import {events, Events} from './Events';\n// import {Pages, P} from './Pages';\nclass Dockable extends Base {\n    constructor(...Arguments) {\n        super();\n        this.buildBase(...Arguments);\n        if (this.rootDisplayCell)\n            this.displaygroup = this.rootDisplayCell.displaygroup;\n        Dockable.makeLabel(this);\n        this.dummy = I(`${this.label}_DockableDummy`);\n    }\n    render(displaycell, parentDisplaygroup, index, derender) {\n        // console.log(\"Moving?\", ToolBar.isMoving)\n        if (ToolBar.isMoving && !ToolBar.activeInstace.isDocked) {\n            let toolbar = Dockable.activeToolbar = ToolBar.activeInstace;\n            let cellArray = this.displaygroup.cellArray;\n            if (!this.dropZones) {\n                this.dropZones = [];\n                for (let index = 0; index < cellArray.length; index++) {\n                    let displaycell1 = cellArray[index];\n                    let newCoord = new Coord();\n                    newCoord.copy(displaycell1.coord);\n                    newCoord.assign(undefined, undefined, undefined, toolbar.sizePx);\n                    this.dropZones.push(newCoord);\n                }\n                let displaycell1 = cellArray[cellArray.length - 1];\n                let newCoord = new Coord();\n                newCoord.copy(displaycell1.coord);\n                newCoord.assign(undefined, displaycell1.coord.height - toolbar.sizePx, undefined, toolbar.sizePx);\n                this.dropZones.push(newCoord);\n            }\n            for (let index = 0; index < this.dropZones.length; index++) {\n                let dropCoord = this.dropZones[index];\n                if (!toolbar.rootDisplayCell.coord.isCoordCompletelyOutside(dropCoord)) {\n                    if (Dockable.open == undefined) {\n                        Dockable.open = index;\n                        this.dummy.dim = `${toolbar.sizePx}px`;\n                        cellArray.splice(index, 0, this.dummy);\n                    }\n                }\n                else {\n                    if (index == Dockable.open) {\n                        Dockable.open = undefined;\n                        cellArray.splice(index, 1);\n                    }\n                }\n            }\n        }\n        else {\n            if (this.dropZones) {\n                if (Dockable.open != undefined) {\n                    let toolbar = Dockable.activeToolbar;\n                    this.displaygroup.cellArray[Dockable.open] = toolbar.rootDisplayCell;\n                    Dockable.open = undefined;\n                    toolbar.isDocked = true;\n                    toolbar.modal.hide();\n                    Handler.update();\n                }\n                this.dropZones = undefined;\n            }\n        }\n    }\n}\nDockable.labelNo = 0;\nDockable.instances = [];\nDockable.activeInstances = [];\nDockable.defaults = { type: \"All\", };\nDockable.argMap = {\n    string: [\"label\", \"type\"],\n    DisplayCell: [\"rootDisplayCell\"],\n};\nfunction dockable(...Arguments) {\n    let overlay = new Overlay(\"Dockable\", ...Arguments);\n    let newDockable = overlay.returnObj;\n    let parentDisplaycell = newDockable.rootDisplayCell;\n    parentDisplaycell.addOverlay(overlay);\n    return parentDisplaycell;\n}\nOverlay.classes[\"Dockable\"] = Dockable;\nclass ToolBar extends Base {\n    constructor(...Arguments) {\n        super();\n        this.buildBase(...Arguments);\n        ToolBar.makeLabel(this);\n        this.spacer = I(`${this.label}_toolbar_spacer`);\n        if (\"DisplayCell\" in this.retArgs) {\n            this.displaycells = this.retArgs[\"DisplayCell\"];\n            for (let index = 0; index < this.displaycells.length; index++) {\n                let displaycell = this.displaycells[index];\n                if (!displaycell.dim)\n                    displaycell.dim = `${this.sizePx}px`;\n            }\n        }\n        if (!this.rootDisplayCell)\n            this.build();\n        this.makeModal();\n    }\n    static startMoveToolbar(THIS, handler) {\n        Modal.movingInstace = THIS.modal;\n    }\n    static moveToolbar(THIS, handler, offset) {\n        THIS.rootDisplayCell.coord.setOffset(offset.x, offset.y);\n        if (Math.abs(offset[\"x\"]) > ToolBar.triggerUndockDistance || Math.abs(offset[\"y\"]) > ToolBar.triggerUndockDistance) {\n            THIS.rootDisplayCell.coord.setOffset();\n            ToolBar.undock(THIS, handler, offset);\n        }\n        Handler.update();\n    }\n    static undock(THIS, handler, offset) {\n        let index = THIS.parentDisplayGroup.cellArray.indexOf(THIS.rootDisplayCell);\n        if (index > -1)\n            THIS.parentDisplayGroup.cellArray.splice(index, 1); // pop from previous DisplayGroup\n        THIS.isDocked = false; // Mark as unDocked\n        Modal.x = THIS.rootDisplayCell.coord.x;\n        Modal.y = THIS.rootDisplayCell.coord.y;\n        let [width, height] = THIS.setModalSize();\n        let x = THIS.rootDisplayCell.coord.x + offset.x;\n        let y = THIS.rootDisplayCell.coord.y + offset.y;\n        THIS.modal.setSize(x, y, width, height);\n        THIS.modal.show();\n    }\n    build() {\n        let THIS = this;\n        let checker = I(`${this.label}_checker`, ToolBar.llm_checker, \"10px\", events({ ondrag: {\n                onDown: function () {\n                    // console.log(\"onDown\");\n                    ToolBar.isMoving = true;\n                    ToolBar.activeInstace = THIS;\n                    return (THIS.isDocked) ? ToolBar.startMoveToolbar(THIS, THIS.modal.handler) : Modal.startMoveModal(THIS.modal.handler);\n                },\n                onMove: function (offset) {\n                    return (THIS.isDocked) ? ToolBar.moveToolbar(THIS, THIS.modal.handler, offset) : Modal.moveModal(THIS.modal.handler, offset);\n                },\n                onUp: function (offset) {\n                    // console.log(\"onUp\");\n                    ToolBar.isMoving = false;\n                    ToolBar.activeInstace = undefined;\n                    Modal.movingInstace = undefined;\n                    if (THIS.isDocked) {\n                        THIS.rootDisplayCell.coord.setOffset();\n                    }\n                    Handler.update();\n                }\n            } }));\n        this.hBar = h(`${this.label}_hBar`, `${this.sizePx}px`);\n        this.vBar = v(`${this.label}_hBar`, `${this.sizePx}px`);\n        this.displaycells.unshift(checker);\n        this.hBar.displaygroup.cellArray = this.vBar.displaygroup.cellArray = this.displaycells;\n        this.rootDisplayCell =\n            P(`${this.label}_toolbar_Pages`, `${this.sizePx}px`, this.hBar, this.vBar, this.sizeFunction);\n    }\n    makeModal() {\n        this.modal =\n            new Modal(`${this.label}_modal`, { fullCell: this.rootDisplayCell }, ...(this.setModalSize()));\n    }\n    setModalSize() {\n        let width = (this.isHor) ? this.displaycells.length * this.sizePx : this.sizePx;\n        let height = (this.isHor) ? this.sizePx : this.displaycells.length * this.sizePx;\n        return [width, height];\n    }\n    sizeFunction(thisPages) {\n        return 0;\n    }\n    render(displaycell, parentDisplaygroup, index, derender) {\n        if (!this.parentDisplayGroup)\n            this.parentDisplayGroup = parentDisplaygroup;\n    }\n}\nToolBar.labelNo = 0;\nToolBar.instances = [];\nToolBar.activeInstances = [];\nToolBar.llm_checker = css(\"llm_checker\", `cursor:pointer;\r\n    --checkerSize: 2px; /* edit me */\r\n    background-image:\r\n      linear-gradient(45deg, lightgrey 25%, transparent 25%), \r\n      linear-gradient(135deg, lightgrey 25%, transparent 25%),\r\n      linear-gradient(45deg, transparent 75%, lightgrey 75%),\r\n      linear-gradient(135deg, transparent 75%, lightgrey 75%);\r\n    background-size: \r\n      calc(2 * var(--checkerSize)) \r\n      calc(2 * var(--checkerSize));\r\n    background-position: \r\n      0 0, \r\n      var(--checkerSize) 0, \r\n      var(--checkerSize) calc(-1 * var(--checkerSize)), \r\n      0px var(--checkerSize);\r\n    /* for fun */\r\n    transition-property: background-position, background-size;\r\n    transition-duration: 2s;`);\nToolBar.defaults = { sizePx: 25, isDocked: true, isHor: true, type: \"All\" };\nToolBar.argMap = {\n    string: [\"label\", \"type\"],\n    // DisplayCell : see constructor,\n    number: [\"sizePx\"],\n};\nToolBar.triggerUndockDistance = 15;\nToolBar.isMoving = false;\nfunction tool_bar(...Arguments) {\n    let overlay = new Overlay(\"ToolBar\", ...Arguments);\n    let newToolBar = overlay.returnObj;\n    let parentDisplaycell = newToolBar.rootDisplayCell;\n    parentDisplaycell.addOverlay(overlay);\n    return parentDisplaycell;\n}\nOverlay.classes[\"ToolBar\"] = ToolBar;\n// export {tool_bar, ToolBar, Dockable, dockable}\n\n\n//# sourceURL=webpack:///./dist/liefs-layout-managerV3.0.0.full.module.js?");

/***/ })

/******/ });
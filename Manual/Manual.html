<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Page Title</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.23.0/min/vs/editor/editor.main.min.css" integrity="sha512-RhnuJxgda82cBylRysVDqdpwnBcSkMzxz1+BxGwBPNMzBJlvaOjHz7P2kXELC0bdNxazsNSyJb7KAww0T5iUdQ==" crossorigin="anonymous" />
    <link href="../prism/prism.css" rel="stylesheet" />
    <script src="../prism/prism.js"></script>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <script src="../dist/liefs-layout-managerV3_FULL.js"></script>
</head>
<style>
    pre {padding:10px;background:Beige;overflow: auto;}
    p {text-indent: 50px;margin:10px;}
</style>
<body>
    <script>
        var require = {paths: {'vs':'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.23.0/min/vs/'}}
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.23.0/min/vs/loader.min.js" integrity="sha512-+8+MX2hyUZxaUfMJT0ew+rPsrTGiTmCg8oksa6uVE/ZlR/g3SJtyozqcqDGkw/W785xYAvcx1LxXPP+ywD0SNw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.23.0/min/vs/editor/editor.main.nls.min.js" integrity="sha512-3aAqsDS5ClTlwyzxufRhW9WMwZlYn3V8GLRl324pMIftp+CA6kvxfjlm8TG7Wi53eBcerEdX0YfXm3QLvf1Pqg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.23.0/min/vs/editor/editor.main.js" integrity="sha512-sOJZBKiSvh/6vxIimdXkjO45Nd3v2n3ZYtrwktgj5SJh0+PCqNQ5oqzxEr6c/o4ULczn1Wo2yh1qrz+ghduDUA==" crossorigin="anonymous"></script>
<script>
//typescript    
let typescript=function(id, newString){
    let x = document.getElementById(id);
    x.innerHTML = Prism.highlight((newString)? newString :x.innerHTML, Prism.languages.typescript, 'typescript');
}
let js=function(id, newString){
    let x = document.getElementById(id);
    x.innerHTML = Prism.highlight((newString)? newString :x.innerHTML, Prism.languages.javascript, 'javascript');
}
let html=function(id, newString){
    let x = document.getElementById(id);
    x.innerHTML = Prism.highlight((newString)?  newString : x.innerHTML, Prism.languages.markup, 'markup');}
let closescript = "</"+"script>";
</script>
<div class="remove" style="font-size: larger;">Loading...</div>
<div class="remove" style="display:none">


<div id="Introduction" class="allowScroll">
    <div class="heading">Introduction</div><p class="body">
Lief's Layout Manager is a  Typescript/Javascript 'div' management framework, which add layout and
event capabilities to your client code.  It works in addition to all your current layout techniques.
</p><div class="subHeading">Use Cases</div><p>
Lief's Layout Manager was designed to make the following easier:
<ul>
    <li>Front End Applications (Electron)</li>
    <li>Dynamic Page Layout (Adjusts for All Screen Sizes)</li>
    <li>Expanded Events (Multiple Functions running onclick for example)</li>
    <li>Dynamic Feedback to 'div's</li>
</ul>    
</p>
</div>



<div id="Installation" class="allowScroll">
    <div class="heading">Installation</div><p>
Lief's Layout Manager is a simply a small amount of javascript code.  Simply add one line to the beginning of your
code.</p>
<pre><code id="Installation1"></code>&lt;/script></pre>
<script>html("Installation1",`<script src="https://leafdriving.github.io/liefs-layout-manager-3.0.0/dist/liefs-layout-managerV3_FULL.js">`);</script>
<p>This will be published on NPM in the near future.</p>
<div handler="core_00_" style="width:100%;height:400px;"></div>
<p>The above code shows a basic example of how to use Liefs-layout-manager.</p>
</div>

<div id="Usage" class="allowScroll">
    <div class="heading">Usage</div><p>
Lief's Layout manager is TINY! (Full is about half of Jquery), however, you can only load what you need.
If you want the entire layout manager, simply use:</p>
<pre><code id="Usage1"></code></pre>
<script>html("Usage1",`<script src="https://leafdriving.github.io/liefs-layout-manager-3.0.0/dist/liefs-layout-managerV3_FULL.js">${closescript}`);</script>
<p>By using this link, you are ensured to have all the components properly loaded.  This is the equivelent to the following:</p>
<pre><code id="Usage2"></code></pre>
<script>html("Usage2",
`<script src="https://leafdriving.github.io/liefs-layout-manager-3.0.0/dist/liefs-layout-managerV3_CORE.js">${closescript}
<script src="https://leafdriving.github.io/liefs-layout-manager-3.0.0/dist/components/Context.js">${closescript}
<script src="https://leafdriving.github.io/liefs-layout-manager-3.0.0/dist/components/DragBar.js">${closescript}
<script src="https://leafdriving.github.io/liefs-layout-manager-3.0.0/dist/components/Modal.js">${closescript}
<script src="https://leafdriving.github.io/liefs-layout-manager-3.0.0/dist/components/Pages.js">${closescript}
<script src="https://leafdriving.github.io/liefs-layout-manager-3.0.0/dist/components/Scrollbar.js">${closescript}
<script src="https://leafdriving.github.io/liefs-layout-manager-3.0.0/dist/components/Selected.js">${closescript}
<script src="https://leafdriving.github.io/liefs-layout-manager-3.0.0/dist/components/Tree.js">${closescript}`);</script>
<p>Lief's Layout Manager is divided in Components, so that you can only load, what you only need, keeping your code size TINY</p>
</div>


<div id="Core" class="allowScroll">
    <div class="heading">Core</div>
    <div class="subHeading">Core of Lief's Layout Manager</div><p>
        Lief's Layout Manager "Core" is the essentials to work this software.</p>
<ul>
<li>A "Handler" (could be many) determines the "outer" dimensions you wish to start with.  By default, its the screen size</li>
<li>This "Handler" is (like all components) within a DisplayCell, which hold the Co-ordinates.</li>
<li>All DisplayCells can be divided up in to rows or columns called DisplayGroups. (Which of course contain an Array of DisplayCells)
DisplayGroups can be nested until you have the desired result</li>
<li>Eventually, you will fill a DisplayCell with an 'Element_'. Element_s are 'div' elements rendered in the dom.</li>
<li>Elements_ can have 'events' attached to them. (onclick, onhover, etc...)</li>
</ul><p>
By combining DisplayCells with Element_s and Events, you can layout ANY rectangular web page.    
</p>
</div>


<div id="Arguments By Type" class="allowScroll">
    <div class="heading">Core</div>
    <div class="subHeading">Arguments By Type</div><p>
Liefs's Layout Manager Objects use "By Type, then Index" notation, rather than standard, "By Index" notation.
Normally, when you define an object or function, the order is critical:</p>
<pre><code id="ABT1"></code></pre>
<script>js("ABT1",`let someFunction = function(firstTypeNumber, typeString, typeFunction, secondTypeNumber){};
new SomeObject(firstTypeNumber, typeString, typeFunction, secondTypeNumber);`);</script>
<p>But Lief's layout manager sees the above as One Number, One String, and One Function.  The order is not important
unless you have multiple entryies as the same type.  This means that Lief's Layout Manager sees this as equivelent to:</p>
<pre><code id="ABT2"></code></pre>
<script>js("ABT2",`let someFunction = function(typeFunction, firstTypeNumber,secondTypeNumber ,typeString){};
new SomeObject(firstTypeNumber, typeString, typeFunction, secondTypeNumber);`);</script>
</div>


<div id="FunctionStack" class="allowScroll">
    <div class="heading">Core</div>
    <div class="subHeading">FunctionStack</div><p>
        Lief's Layout Manager implements FunctionStack, which is a simple way to stack functions on all events.
        It works on any event.</p>
<pre><code id="FunctionStack1">window.onmousemove = FunctionStack.push(window.onmousemove, function one(){console.log("one")});
window.onmousemove = FunctionStack.push(window.onmousemove, function two(){console.log("two")});
window.onmousemove = FunctionStack.push(window.onmousemove, function three(){console.log("three")});
window.onmousemove = FunctionStack.push(window.onmousemove, function four(){console.log("four")});</code></pre>
<script>js("FunctionStack1");</script>
<p>Now, the window.onmousemove event triggers ALL of the functions. To remove an object, just pop it using the name of the function</p>
<pre><code id="FunctionStack2">window.onmousemove = FunctionStack.pop(window.onmousemove, "one");</code></pre>
    <script>js("FunctionStack2");</script>
<p>You can try the above code in the Console (F12) now.</p>
</div>


<div id="Coord" class="allowScroll">
    <div class="heading">Coord</div>
<p>A Coord Object simply stores the x, y, width, height, and zindex of an element.  The instance
properties are as follows:
</p>
<pre><code id="Coord">label:string; // label of the Coord
frozen:boolean; // if true, it cant be changed until set to false again
x: number;  // the x component
y: number;  // the y component
width_: number; // the width component
height: number; // the height component
x2:number;      // read only - returns x + width
y2:number;      // read only - return y + width
zindex: number;
within: Within = new Within();
hideWidth: boolean;
offset: {x:number, y:number, width:number, height:number};
setOffset(x=0, y=0, width=0, height=0);
assign(x=undefined, y=undefined, width=undefined, height=undefined,
        wx=undefined, wy=undefined, wwidth=undefined, wheight=undefined, zindex=undefined);
copy(fromCoord:Coord,
    x:number=undefined, y:number=undefined, width:number=undefined, height:number=undefined,
    zindex:number=undefined):Coord;
log();
isCoordCompletelyOutside(WITHIN: Coord|Within = this.within):boolean;
isPointIn(x:number, y:number): boolean;
    
</code></pre>
    <script>typescript("FunctionStack2");</script>

        
</div>


<div id="DisplayCell" class="allowScroll">
    <div class="heading">Core</div>
    <div class="subHeading">DisplayCell</div><p>
Lief's layout manager creates a "Render Tree".  There is a root object, then children of that, then children of those,
and so on.  Each of these "nodes" are wrapped in a DisplayCell Object,</p>
<pre><code id="DisplayCell_1">let myNewDisplayCell = new DisplayCell("someName")</code></pre>
<script>js("DisplayCell_1");</script>
<p>There are a few ways of implementing this wrapping process.</p>
<pre><code id="DisplayCell2">let myNewDisplayCell = new DisplayCell( new Element_("myElementName") );
let myNewDisplayCell = new DisplayCell().addComponent( new Element_("myElementName"));
let myNewDisplayCell = I("myElementName");
</code></pre>
<script>js("DisplayCell2");</script>
<p>The above lines are all equivelent.  It depends on how you like to build your project.</p>

<div class="subHeading">DisplayCell - Deep Dive</div>
<p>A DisplayCell Instance has the following properties and methods</p>
<pre><code id="DisplayCell3">coord: Coord;                // Each DisplayCell has a Co-ordinates Object (Assigned Automatically)
children: Component[];                                    // Array of children Objects in render Tree
parentDisplayCell: DisplayCell;                           // If not the root DisplayCell, it's parent DisplayCel
marginLeft: number;                                       // optional Margin
marginRight: number;                                      // optional Margin
marginTop: number;                                        // optional Margin
marginBottom: number;                                     // optional Margin
node: node_;                                              // Render Node - Created during the Render Process (Designed as Read Only)
dim: string;                                              // a number string ending with either "px" or "%" - used with DisplayGroup
min: number;                                              // a minimum number of pixels this cell will be in a DisplayGroup (Default 1)
addComponent(component: Component): DisplayCell;          // Add a child Component.
getComponent(type: string, label?: string): object;       // Get a Child Component for example ("DisplayGroup", "myDisplayGroup")
deleteComponent(type: string, label?: string): boolean;   // Delete a child Component for example ("DisplayGroup", "myDisplayGroup")
addEvents(Argument: object): void;                        // Assuming Child "Element_" -> Adds events to the child
</code></pre>
<script>typescript("DisplayCell3");</script>
<pre><code id="DisplayCell4">//Example
let leftSideElement = new Element_("Left Side", "Left Side InnerHtml");
let leftSide = new DisplayCell( "200px",{
    marginLeft: 10,
    marginRight: 5,
    marginTop: 2,
    marginBottom : 7,
}).addComponent( leftSideElement ).addEvent({onclick:function(){console.log("left clicked")}});
let rightSide = I("Right Side","Right Side InnerHtml", events({console.log("right clicked")}));
let horizontal = h("horizontalDisplayGroup",leftSide, rightSide)
horizontal.marginLeft = 20;
H("SomeHandler", horizontal);
</code></pre>
    <script>js("DisplayCell4");</script>
<p>DisplayCell Object (static, not instance) has the following properties:</p>
<pre><code id="DisplayCell5">static instances:{[key: string]: DisplayCell;} = {};
static defaults:{[key: string]: any;};
static argMap:{[key: string]: Array<string>;}
static objectTypes:Set<string>;
//to look at these type this in the Console:
DisplayCell.instances               // Stores all instances Created in an Object
DisplayCell.defaults                // Default instance values
DisplayCell.argMap                  // A mapping of argument types, to properties
DisplayCell.objectTypes             // All Componenets registered (to check if non core componenet is loaded)
</code></pre>
<script>typescript("DisplayCell5");</script>
</div>


<div id="DisplayGroup" class="allowScroll">
    <div class="heading">Core</div>
    <div class="subHeading">DisplayGroup</div><p>
DisplayGroups divide a DisplayCell in to either a Horizontal Array, or a Vertical Array.
The size of each item in the Array is determined by the "dim" value of each child DisplayCell.
Any string that ends with "%" or "px" is recgonized as a "dim" value.  DisplayGroups are the most common
way to layout your screen.</p>
<div handler="core_displaygroup01_" style="width:100%;height:400px;"></div><p>
The Above example illistrates how to nest 'DisplayGroups' with 'Element_'s.
<ul><li>lines 1-5 defines css classes</li>
    <li>line 6 defines button arrays</li>
    <li>line  defines 'events' -> onclick, alert what was clicked</li>
    <li>lines 8-11 define top and bottom buttons as Element_s (wrapped in DisplayCells)</li>
    <li>line 12 Create a Handler, with and outside margin of 10 pixels</li>
    <li>line 13 Create a vertical DisplayGroup with 2 pixels between vertical cells</li>
    <li>line 14 Create an Element_ ('div') to be the Top 'div' </li>
    <li>line 15 Create a Horizontal DisplayGroup of Buttons -> Note The spread operator ...b1 50 pixels high</li>
    <li>line 16 Create a Horizontal DisplayGroup of "Left" and "right" side, 2 pixels between them</li>
    <li>line 17 Create an Element_ "left" which is FIXED to 200 pixels</li>
    <li>line 18 Create a Vertical DisplayGroup on the "right"</li>
    <li>line 19 Create a Top Element_ on the right side</li>
    <li>line 20 Create a Bottom Element_ on the right side</li>
    <li>line 23 Create a Horizontal DisplayGroup of Buttons -> Note The spread operator ...b2 50 pixels high</li>
    <li>line 24 Create an Element_ ('div') to be the Top 'div' </li>
</ul>A DisplayGroup Instance has the following properties and methods</p>
<div class="subHeading">DisplayGroup - A Deep Dive</div>
<pre><code id="DisplayGroup1">allowScrollBar:boolean;         // set to be true, if a scrollbar is desired (and loaded - Componenet, not Core)
label:string;                   // the label for this instance
dim:string;                     // Used if this DisplayGroup, is a child of a different DisplayGroup
margin:number;                  // The distance bewteen the Cells of the DisplayGroup
node:node_;                     // Render Node -> Created a Render stage.
parentDisplayCell:DisplayCell;  // It's DisplayCell Parent
children: DisplayCell[] = [];   // The Array of Child DisplayCells
isHor: boolean;                 // true (default) if Horizontal, false if vertical
scrollbar: ScrollBar;           // Active Scrollbar (Assuming allowScrollBar is true, and Scrollbar Comonenet is loaded)
offset:number;                  // Internal use -> offset provided by scrollbar</code></pre>
<script>typescript("DisplayGroup1");</script>
<p>DisplayGroup Object (static, not instance) has the following properties:</p>
<pre><code id="DisplayGroup2">static instances:{[key: string]: DisplayGroup;}
static defaults:{[key: string]: any;};
static argMap:{[key: string]: Array<string>;};
// So, in the Console, try:
DisplayGroup.instances
DisplayGroup.defaults
DisplayGroup.argMap
</code></pre>
<script>typescript("DisplayGroup2");</script>
</div>




<div id="Handler" class="allowScroll">
    <div class="heading">Core</div>
    <div class="subHeading">Handler</div><p>
The "Handler" object is a "Root" node of a Render Tree.  By Default, Handlers use the outer screen size
as the default.  Handler size can be assigned programatically, or assigned to some other 'div'</p>
<pre><code id="DisplayCell1">let myNewHandler = new Handler("someName"); let handlerDisplayCell = new DisplayCell( myNewHandler );
let handlerDisplayCell = new DisplayCell("someName").addComponent( new Handler("someName") );
let handlerDisplayCell = H("someName");</code></pre>
<p>The above lines are all equivelent.  Again, it depends how you like to program.</p>
<script>js("DisplayCell1");</script>
<div class="subHeading">DisplayGroup - A Deep Dive</div>
<p>A Handler Instance has the following Properties:</p>
<pre><code id="Handler_1">
type: string;                           // the type of Handler (modals go to the top layer)
label: string;                          // the label of the Hander
startRendered: boolean;                 // if true, render on define, if false await handlerInstance.show();
coord: Coord;                           // co-ordinate of the Handler ()
parentDisplayCell: DisplayCell;         // Parent DisplayCell, holding the Handler
children: Component[];                  // Children to be rendered
node: node_;                            // Render Node, Created when Rendered
preRenderCallBack: function(handler: Handler){};  // optional callback
postRenderCallBack: function(handler: Handler){}; // optional callback
show(): void;                           // shows the handler rendered
hide(): void;                           // remove the handler, and stop rendering it</code></pre>
<script>typescript("Handler_1");</script><p>
A Handler static (not instance) methods are as follows:
</p><pre><code id="Handler_2">Handler.instances:{[key: string]: Handler;};
Handler.defaults:{[key: string]: any;};
Handler.argMap:{[key: string]: Array<string>;}
Handler.ScreenSizeCoord: Coord;</code></pre>
<script>typescript("Handler_2");</script>
</div>




<div id="Element_" class="allowScroll">
    <div class="heading">Core</div>
    <div class="subHeading">Element_</div><p>
Lief's Layout Manager manages a div with an Element_ Object.</p>
<pre><code id="Element_1">let myNewDisplayCell = new DisplayCell( new Element_("myElementName") );
let myNewDisplayCell = new DisplayCell().addComponent( new Element_("myElementName"));
let myNewDisplayCell = I("myElementName");
</code></pre><p>
Lets stick to the 3rd method, because it uses less code.  To create an element, ('div') simply create one as follows:</p>
<pre><code id="Element_2">let myNewElement = I("SomeName", "This is the 'innerHTML' of the div", "cssClassName");
// Completely Created in Javascript
let myNewElement = I("SomeName", {css:"cssClassName"});
// since no innerHTML was specified, checks the dom for a 'div' with id="SomeName"
</code></pre>
<script>js("Element_2");</script>
<div class="subHeading">Element_ a Deep Dive</div><p>
An Element_ instance has the following Properties:</p>
<pre><code id="Element_3">ignoreInner:boolean;      // set true if some "funtionality" sets the innerHTML
label:string;       // label of the Element_
el:HTMLDivElement;  // the actual div element in the dom
evalInner:function(THIS:Element_){return string};  // function to set the value of the innerHTML
innerHTML:string;   // value of innerHTML (if constant)
css:string;         // the class="css" value
dim:string;         // used in DisplayGroup, and passed on to the parent DisplayCell
Css:Css;            // Setting the CSS using a Css Instance
events:objectFunction;  // an object that holds events ie: {onclick:function(){console.log("clicked")}}
processEvents:objectFunction;   // a pre-holding place for events, so FunctionStack can be applied
attributes:objectString;        // attribute object for the div element, for example {title:"On Hover Comment"}
parentDisplayCell: DisplayCell; // Parent DisplayCell (Co-Ordinates of Element_)
addEvents(eventObject:object);  // add events (which can be stacked) to an Element_, for example {onclick:function(){console.log("clicked")}}
</code></pre>
<script>typescript("Element_3");</script>
<p>The Element_ Object has the following Static Properties</p>
<pre><code id="Element_4">Element_.instances:{[key: string]: Element_;}
Element_.defaults:{[key: string]: any;}
Element_.argMap:{[key: string]: Array<string>;}
Element_.customEvents:{[type: string]: (newData:any)=>object;};
</code></pre>
<script>typescript("Element_4");</script>
</div>



<div id="Events" class="allowScroll">
    <div class="heading">Events</div>
<p>Events are attached to 'Elements_' ('div')'s.  This is done as shown:</p>
<pre><code id="Events_1">let SomeNameEvents = events({onclick:function(e){console.log(e,this);}})
let myNewElement = I("SomeName", "This is the 'innerHTML' of the div", "cssClassName", SomeNameEvents);
// Completely Created in Javascript
let myNewElement = I("SomeName", {css:"cssClassName"}, events({onclick:function(e){console.log(e,this);}}));
// since no innerHTML was specified, checks the dom for a 'div' with id="SomeName"
</code></pre>
<script>js("Events_1");</script>
<div handler="core_displaygroup01_" style="width:100%;height:400px;"></div>
<p>In the above example, we have attached the same 'onclick' event to all Elements_, however we could
attach any event(s) as selectivly as we choose.</p>
<p>Events Can be Stacked.  For Example, you can add or remove multiple events of the same time to an element</p>
<div handler="events_00_" style="width:100%;height:400px;"></div>
</div>



<div id="node_" class="allowScroll">
    <div class="heading">node_</div>
<p>a node_ is a basic tree object that has a parent, and children (so a tree object).
By itself, it doesn't do a lot, but you can use it to assign data to a tree form.
When objects are rendered, they produce a tree.  For example: try this in the console:</p>
<pre><code id="node_1">function sample(){
    let node = new node_();                     // first you create a root node
    node.newChild("One")                        // the first child IS the top node
            .newChild("One-A")
                .newChild("One-A-1")
                .newSibling("One-A-2")
            .parent()                           // be sure to use .parent() to move back up the tree
            .newSibling("One-B")
                .newChild("One-B-1")
                .newSibling("One-B-2")
                    .newChild("One-B-2-1")
                .parent()                       // be sure to use .parent() to move back up the tree
            .parent()                           // be sure to use .parent() to move back up the tree
            .newSibling("One-C")
        .parent()                               // be sure to use .parent() to move back up the tree
        .newSibling("Two")
            .newChild("Two-A")
                .newChild("Two-A-1")
            .parent()                           // be sure to use .parent() to move back up the tree
            .newSibling("Two-B")
        .parent()                               // be sure to use .parent() to move back up the tree
        .newSibling("Three")
    return node;
}</code></pre><script>js("node_1");</script>
<p>This sample is built in to Lief's Layout manager. To view it, simply type:</p>
<pre><code id="node_2">// Try this in the console now! (F12)
let node = sample(); // create the above node tree
node.log() // show tree, without object nodes
node.log(true) // show tree with object nodes
</code></pre><script>js("node_2");</script>
<p>This is the standard tree object used with Lief's layout manager.  By looking at:</p>
<pre><code id="node_3">Render.node.log(true);  // try this in the console now!</code></pre><script>js("node_3");</script>
<p>You can see how the elements on the page are rendered</p>
</div>



<div id="Render" class="allowScroll">
    <div class="heading">Render</div>
<p>The Render object renders the output to the screen.  Whenever you change anything that changes the content
on the screen, use:</p>
<pre><code id="Render_1">Render.scheduleUpdate();  // tells the system to update on next tic (so now)</code></pre><script>js("Render_1");</script>
</div>



<div id="Examples" class="allowScroll">
    <div class="heading">Examples</div>
<p>I hope the following Exmaples help explain how Lief's Layout Manager Works.</p>
</div>



<div id="Components" class="allowScrollBar">
    <div class="heading">Components</div>
<p>Components are additional functionality added to Lief's Layout Manager.</p>
</div>



<div id="Context" class="allowScroll">
    <div class="heading">Context</div>
<p>Context is simply a drop down menu.  This could occur on a "right-click" or a "click" or a "onhover" etc... 
How it is used is up to you.  Lets look at an example.</p>
<div handler="context_01_" style="width:100%;height:400px;"></div>
</div>


<div id="DragBar" class="allowScroll">
    <div class="heading">DragBar</div>
<p>A DragBar resizes one DisplayCell within a DisplayGroup.</p>
<div handler="DragBar_01_" style="width:100%;height:400px;"></div>
</div>


<div id="Modal" class="allowScroll">
    <div class="heading">Modal</div>
<p>A Modal is a Handler, defined within a "window".</p>
</div>



<div id="Pages" class="allowScroll">
    <div class="heading">Pages</div>
<p>The Pages Object describes a 'div' that could have different values.  Each Value, is refered to as a page.</p>
<div handler="Pages_01_" style="width:100%;height:400px;"></div>
<p>Some Comment</p>
<div handler="Pages_02_" style="width:100%;height:400px;"></div>
<p>Some Comment</p>
<div handler="Pages_03_" style="width:100%;height:400px;"></div>
<p>Some Comment</p>
<div handler="Pages_04_" style="width:100%;height:400px;"></div>
</div>


<div id="Scrollbar" class="allowScroll">
    <div class="heading">Scrollbar</div>
<p>A ScrollBar</p>
<div handler="Scrollbar_01_" style="width:100%;height:400px;"></div>
</div>


<div id="Selected" class="allowScroll">
    <div class="heading">Selected</div>
<div handler="Selected_01_" style="width:100%;height:400px;"></div>    
</div>


<div id="Tree" class="allowScroll">
    <div class="heading">Tree</div>
</div>





<div id="Handler 01" class="allowScroll">
    <div class="heading">Handler Example 01</div>
<p>Let's look at our origional example again</p>
<div handler="core_00_" style="width:100%;height:400px;"></div>
<p>The Above Examples Shows:
<ul>
    <li>two css creations class="greenBG" and class="blueBG.  If you check the dom,
(F12) you can see the css was passed on here</li>
<li>The Creation of a "Handler" labeled "core_00" containing a Horizontal DisplayGroup</li>
<li>The Creation of a Horizontal DisplayGroup labeled "core_00_h" within the handler</li>
<li>The Creation of Two Elements_ labeled "core_00_left" and "core_00_right"</li>
<li>the "false" flag indicates NOT to show the handler upon creation, but to await HandlerInstance.show()</li>
</ul>
These Objects can be accessed by their "labels".  For example, try this in the console now (F12) *Note you must click Show Render Above First*</p>
<pre><code id="Handler 01_1">// * Note * try these lines one at a time, as each represents an object.
Css.instances.greenBG                   // By Defining Css in Javascript, you can modify it easily in Javascript
Css.instances.blueBG                    // a css file WILL work fine like normal, but I like it all in one place.
Handler.instances.core_00               // The Handler instance defined with H() (wrapped in a DisplayCell)
DisplayGroup.instances.core_00_h        // The DisplayGroup instance h() 'h' for Horizontal, (wrapped in a DisplayCell)
Element_.instances.core_00_left         // The Element_ instance "core_00_left" ('div') (wrapped in a DisplayCell)
Element_.instances.core_00_right        // The Element_ instance "core_00_right" ('div') (wrapped in a DisplayCell)
DisplayCell.instances.core_00           // This is the DisplayCell that wraps the Handler,
DisplayCell.instances.core_00_h         // This is the DisplayCell that wraps the DisplayGroup,
DisplayCell.instances.core_00_left      // This is the DisplayCell that wraps the Element_ labeled left
DisplayCell.instances.core_00_right     // This is the DisplayCell that wraps the Element_ labeled right
</code></pre>
    <script>js("Handler 01_1");</script>
<p>Margins can be set on ANY DisplayCell.  The following shows how to apply Margins.</p>
<div handler="core_01_" style="width:100%;height:400px;"></div>
</div>







</div></body>
</html>
<script>
    require.config({paths: {'vs':'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.23.0/min/vs/'}})
  let monacoContainer = function(code, language="html", elementId = 'container'){
      var editor;
      require(['vs/editor/editor.main'], function () {
          editor = monaco.editor.create(document.getElementById(elementId), {
              value: code,
              language: language,
          });
          editor.updateOptions({ readOnly: true })
      });
      return editor;
  }
  </script>
<script src="Manual.js"></script>